<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/java.css">
    <title>Java Anotações</title>
</head>
<body>
    <nav>
        <ul>
            <li class="link"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/index.html">Documentação Java</a></li>
            <li class="link"><a href="https://www.alura.com.br/apostila-java-orientacao-objetos">Apostila Java</a></li>
            <li class="link"><a href="https://www.alura.com.br/artigos/poo-programacao-orientada-a-objetos">Artigo sobre POO</a></li>
            <li class="link"><a href="https://www.alura.com.br/artigos/ordenando-colecoes-com-comparable-e-comparator">Artigo Ordenando Listas</a></li>
            <li class="link"><a href="https://www.alura.com.br/artigos/estruturas-de-dados-introducao">Artigo Estruturas de dados: uma introdução</a></li>
            <li class="link"><a href="https://www.alura.com.br/artigos/estrutura-dados-computacao-na-pratica-com-java">Artigo Estrutura de Dados: computação na prática com Java</a></li>
            <li class="link"><a href="https://www.alura.com.br/podcast/hipsterstech-algoritmos-e-estrutura-de-dados-hipsters-186-a375">Podcast  Algoritmos e estrutura de dados - Hipsters #186 </a></li>
            <li class="link"><a href="https://www.alura.com.br/artigos/estruturas-de-dados-introducao">Artigo Estruturas de dados: uma introdução</a></li>
            
        </ul>
    </nav>
    <nav>
        <ul>
            <li class="link"><a href="https://mvnrepository.com/">MVN Repository</a></li>
            <li class="link"><a href="https://omdbapi.com/">API OMDb - banco de dados de filmes abertos</a></li>
        </ul>
    </nav>
    <nav>
        <h1 class="titulo">Cursos</h1>
        <ul>
            <li class="link"><a href="https://cursos.alura.com.br/course/introducao-design-patterns-java">Design Patterns em Java I: boas práticas de programação</a></li>
            <li class="link"><a href="https://cursos.alura.com.br/course/avancando-design-patterns-java">Design Patterns em Java II: avançando nas boas práticas de programação</a></li>
        </ul>
    </nav>
    <main>
        <section>
            <h1 class="titulo">Formatação de texto</h1>
            <p>Em Java, é possível formatar textos e números de diversas maneiras. Isso pode ser útil em diversas situações, como ao exibir valores para o usuário de uma maneira mais legível.</p>
            <p>Uma das maneiras mais comuns de se formatar textos em Java é utilizando o método format(), da classe String. Esse método permite formatar um texto utilizando diversos placeholders, que são representados pelo caractere % seguido de uma letra que indica o tipo de dado que será inserido no placeholder. Por exemplo, %s indica que uma String será inserida no placeholder, %d indica um valor inteiro e %f indica um valor de ponto flutuante. Vamos ver um exemplo:</p>

            <Pre>

                String nome = "Maria";
                int idade = 30;
                double valor = 55.9999;
                System.out.println(String.format("Meu nome é %s, eu tenho %d anos e hoje gastei %.2f reais", nome, idade, valor));

            </Pre>

            <p>Nesse exemplo, os valores das variáveis nome, idade e valor são passados como parâmetros para o método String.format, substituindo os placeholders %s, %d e %.2f, respectivamente. O resultado impresso será "Meu nome é Maria, eu tenho 30 anos e hoje gastei 55,99 reais". Perceba também que o placeholder %.2f indica que o valor deve ser formatado com duas casas decimais.</p>
            <p>Esse exemplo do que foi feito para o String.format também pode ser usado com Text Block, onde usa-se o método que citei em aula, o formatted, para informar as variáveis que deverão ser utilizadas no lugar dos placeholders. Veja esse exemplo:</p>

            <pre>

                String nome = "João";
                int aulas = 4;
                
                String mensagem = """
                Olá, %s!
                Boas vindas ao curso de Java.
                Teremos %d aulas para te mostrar o que é preciso para você dar o seu primeiro mergulho na linguagem!
                """.formatted(nome, aulas);
                
                System.out.println(mensagem);
                Copiar código
                O resultado impresso será:
                
                Olá, João!
                
                Boas vindas ao curso de Java.
            </pre>
        </section>
        <section>
            <h1 class="titulo">Tipos Primitivos em Java</h1>
            
            <h3>boolean</h3>
            <p>O tipo boolean é utilizado para representar valores lógicos, podendo assumir apenas dois valores: true ou false. É utilizado em expressões condicionais, loops e outros casos onde se deseja avaliar se uma determinada condição é verdadeira ou falsa.</p>
            
            <h3>byte</h3>
            <p>O tipo byte é utilizado para representar valores numéricos inteiros de 8 bits. Ele possui uma faixa de valores de -128 a 127.</p>

            <h3>char</h3>
            <p>O tipo char é utilizado para representar caracteres individuais. Ele pode armazenar qualquer caractere Unicode e é representado por aspas simples ('').</p>

            <h3>short</h3>
            <p>O tipo short é utilizado para representar valores numéricos inteiros de 16 bits. Ele possui uma faixa de valores de -32.768 a 32.767.</p>

            <h3>int</h3>
            <p>O tipo int é utilizado para representar valores numéricos inteiros de 32 bits. É um dos tipos de dados mais utilizados para representar números inteiros em Java e possui uma faixa de valores de -2.147.483.648 a 2.147.483.647.</p>

            <h3>long</h3>
            <p>O tipo long é utilizado para representar valores numéricos inteiros de 64 bits. Ele é utilizado para representar valores inteiros muito grandes e possui uma faixa de valores de -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807.</p>

            <h3>float</h3>
            <p>O tipo float é utilizado para representar valores numéricos de ponto flutuante, ou seja, valores com casas decimais, sendo que ocupa 32 bits de memória. Ele pode representar números decimais com até sete dígitos e tem uma precisão limitada, o que significa que ele pode arredondar os números se eles forem muito grandes ou muito pequenos.</p>

            <h3>double</h3>
            <p>O tipo double é similar o float, entretanto ele ocupa 64 bits de memória e pode representar números decimais com até 15 dígitos.</p>
        </section>
        <section>
            <h1 class="titulo">Utilizando Scanner</h1>
            <pre>

                public class ExemploScanner {
                    public static void main(String[] args) {
                        Scanner scanner = new Scanner(System.in);
                        
                        System.out.print("Digite seu nome: ");
                        String nome = scanner.nextLine();
                        System.out.print("Digite sua idade: ");
                        int idade = scanner.nextInt();
                        System.out.print("Digite o valor que pretende investir esse mês: ");
                        double valor = scanner.nextDouble();
                        
                        System.out.println(nome + " que tem " + idade + " anos, irá investir R$ " + valor + " esse mês.");
                        
                        scanner.close();
                    }
                }
            </pre>

            <h2>Erro fantasma no scanner</h2>
            <p>Quando você usa nextDouble() (ou nextInt()), o Scanner lê apenas o número. O caractere de "quebra de linha" (\n), que é gerado quando você aperta Enter, continua parado no "buffer" (a memória temporária do teclado).</p>
            <p>Na próxima vez que o código executa o nextLine(), ele encontra esse \n sobrando, acha que você enviou uma linha vazia e "pula" a leitura da descrição, indo direto para o próximo nextDouble().</p>
            <p>Muitos programadores preferem ler tudo com nextLine() e converter para o número depois. Isso evita qualquer confusão com o buffer.</p>
            <p class="codigo">double valor = Double.parseDouble(scanner.nextLine());</p>
        </section>
        <section>
            <h1 class="titulo">Utilizando for</h1>
            <pre>

                import java.util.Scanner;
                
                public class Loop {
                    public static void main(String[] args) {
                        Scanner leitura = new Scanner(System.in);
                        double mediaAvaliacao = 0;
                        double nota = 0;
                        
                        for (int i = 0; i < 3; i++) {
                            System.out.println("Diga sua avaliação para o filme  ");
                            nota = leitura.nextDouble();
                            mediaAvaliacao += nota;
                        }
                        
                        System.out.println("Média de avaliações " + mediaAvaliacao/3);
                        
                    }
                }
            </pre>
        </section>
        <section>
            <h1 class="titulo">Utilizando While</h1>
            <pre>

                import java.util.Scanner;
                
                public class OutroLoop {
                    public static void main(String[] args) {
                        Scanner leitura = new Scanner(System.in);
                        double mediaAvaliacao = 0;
                        double nota = 0;
                        int totalDeNotas = 0;
                        
                        while (nota != -1) {
                        System.out.println("Diga sua avaliação para o filme ou -1 para encerrar  ");
                        nota = leitura.nextDouble();
                        
                        if (nota != -1) {
                            mediaAvaliacao +=  nota;
                            totalDeNotas++;
                        }
                        
                    }
                    
                    System.out.println("Média de avaliações " + mediaAvaliacao / totalDeNotas);
                }
            }
            </pre>
        </section>
        <section>
            <h1 class="titulo">construtor padrão</h1>

            <p>Em Java, um construtor é um método especial usado para criar e inicializar um objeto recém-criado. Quando uma classe é definida, ela pode ter um ou mais construtores, sendo que se nenhum construtor for definido explicitamente, o Java criará um construtor default (padrão) automaticamente.</p>

            <p>Um construtor default é um construtor que não possui parâmetros e não executa nenhuma instrução. Ele é chamado sempre que um objeto da classe é criado sem argumentos. Por exemplo:</p>
            <pre>
                public class Pessoa {
                    
                    private String nome;
                    private String email;
                    
                    public Pessoa() {
                    }
                    
                    //metodos getters/setters
                }
            </pre>

            <p>No exemplo de código anterior, a classe Pessoa possui um construtor default, que será exatamente o mesmo construtor que o Java criará automaticamente, caso nenhum construtor tivesse sido definido na classe.</p>

            <p>Se uma classe define explicitamente um ou mais construtores, mas não define um construtor sem parâmetros, então não há construtor default. Nesse caso, se um objeto é criado sem argumentos, um erro de compilação será gerado.</p>

            <p>É importante ressaltar que mesmo que um construtor default possa ser útil em alguns casos, é sempre recomendável definir explicitamente os construtores da classe, especialmente se a classe tiver atributos que precisam ser inicializados com valores específicos ou obrigatórios. Isso também torna o código mais claro e fácil de entender.</p>
        </section>

        <section>

            <h1 class="titulo">Modificadores de Acesso</h1>
            <p>Em Java, os modificadores de acesso são palavras-chave que definem o nível de visibilidade de classes, atributos e métodos, sendo que eles ajudam a garantir a segurança e encapsulamento do código.</p>
            <p>Existem quatro tipos de modificadores de acesso em Java: public, protected, private e default (também conhecido como package-private).</p>
            
            <h2>Public</h2>
            <p>O modificador de acesso public é o mais permissivo de todos. Uma classe, atributo ou método declarado como public pode ser acessado por qualquer classe em qualquer pacote. Ou seja, ele possui visibilidade pública e pode ser utilizado livremente. Por exemplo:</p>
            <pre>
                <span class="pre1">public</span> class Conta {

                    <span class="pre1">public</span> double saldo;

                    <span class="pre1">public</span> void sacar(double valor) {
                        // lógica de saque...
                    }
                }
            </pre>
            
            <h2>Default (Package-private)</h2>
            <p>O modificador de acesso default é aquele que não especifica nenhum modificador de acesso. Quando nenhum modificador de acesso é especificado, a classe, atributo ou método pode ser acessado apenas pelas classes que estão no mesmo pacote. Por exemplo:</p>
            <pre>
                package br.com.alura.conta;

                public class Conta {

                    double saldo;

                    void sacar(double valor) {
                        // lógica de saque...
                    }
                }
            </pre>
            <pre>
                package br.com.alura.testes;

                public class Principal {
                    
                    public static void main(String[] args) {
                        Conta c1 = new Conta();
                        c1.saldo = 300;
                        c1.sacar(100);
                    }

                }
            </pre>
            <p>No código anterior, a classe Conta está em um pacote e a classe Principal em outro pacote distinto. A classe Conta pode ser instanciada dentro da classe Principal, pois ela possui o modificador de acesso public, entretanto, o atributo saldo e o método sacar tem o modificador default e, portanto, não podem ser acessados de dentro da classe Principal, o que vai causar um erro de compilação no código anterior.</p>
            
            <h2>Private</h2>
            <p>O modificador de acesso private é o mais restritivo de todos. Uma classe, atributo ou método declarado como private só pode ser acessado dentro da própria classe. Ou seja, ele possui visibilidade restrita e não pode ser utilizado por outras classes. Por exemplo:</p>
            <pre>
                public class Conta {

                    <span class="pre1">private</span> double saldo;

                    <span class="pre1">private</span> void sacar(double valor) {
                        // lógica de saque...
                    }
                }
            </pre>

            <h2>Protected</h2>
            <p>Ao usar herança no Java, temos a possibilidade de utilizar o modificador de acesso protected, que permite que os atributos de uma classe sejam acessados por outras classes do mesmo pacote e também por suas subclasses, independentemente do pacote em que se encontram.</p>
            <p>O modificador protected é útil em situações em que uma classe precisa permitir que suas subclasses acessem diretamente seus atributos, sem a necessidade de restringir o acesso apenas pelos métodos getters e setters. Por exemplo, suponha que temos as seguintes classes em um projeto:</p>

            <pre>
                public class Conta {

                    private String titular;
                    private double saldo;

                    public void sacar(double valor) {
                        //implementacao do metodo omitida
                    }

                    public void depositar(double valor) {
                        //implementacao do metodo omitida
                    }

                    //getters e setters
                }
            </pre>
            <pre>
                public class ContaPoupanca extends Conta {

                    private double taxaDeJuros;

                    public void calcularJuros() {
                        double juros = this.getSaldo() * taxaDeJuros;
                        System.out.println("Juros atual: " +juros);
                    }

                    //getters e setters
                }
            </pre>
            <p>No código anterior, repare que no método calcularJuros, da classe ContaPoupanca, o atributo saldo não é acessado diretamente, pois ele foi declarado como private na classe Conta, devendo então seu acesso ser feito pelo método getSaldo().</p>
            <p>Podemos declarar o atributo saldo como protected, para evitar essa situação e liberar o acesso direto a ele pelas classes que herdam da classe Conta:</p>
            <pre>
                public class Conta {

                    private String titular;
                    protected double saldo;

                    public void sacar(double valor) {
                        //implementacao do metodo omitida
                    }

                    public void depositar(double valor) {
                        //implementacao do metodo omitida
                    }

                    //getters e setters
                }
            </pre>
            <pre>
                public class ContaPoupanca extends Conta {

                    private double taxaDeJuros;

                    public void calcularJuros() {
                        double juros = this.saldo * taxaDeJuros;
                        System.out.println("Juros atual: " +juros);
                    }

                    //getters e setters
                }
            </pre>
            <p>Repare que agora o atributo saldo foi acessado diretamente pela classe ContaPoupanca.</p>
            
        </section>
        <section>

            <h1 class="titulo">Herança</h1>
            <p>A herança é um conceito fundamental da orientação a objetos, sendo implementada em Java através da relação é um entre classes. Isso significa que uma classe pode herdar atributos e métodos de outra classe, tornando com isso o código mais reutilizável.</p>
            <p>No Java, a herança é realizada através da palavra-chave extends. A classe que herda é chamada de subclasse, e a classe que é herdada é chamada de superclasse. A subclasse pode acessar todos os atributos e métodos públicos e protegidos da superclasse, além de poder sobrescrever os métodos da superclasse para criar comportamentos específicos.</p>
            <p>Por exemplo:</p>
            <pre>
                public class Conta {

                    private String titular;
                    private double saldo;

                    public void sacar(double valor) {
                        if (valor <= 0) {
                        System.out.println("Valor deve ser maior do que zero!");
                        } else if (saldo >= valor) {
                        saldo -= valor;
                        System.out.println("Saque realizado com sucesso. Saldo atual: " +saldo);
                        } else {
                        System.out.println("Saldo insuficiente.");
                        }
                    }

                    public void depositar(double valor) {
                        if (valor > 0) {
                        saldo += valor;
                        System.out.println("Depósito realizado com sucesso. Saldo atual: " +saldo);
                        } else {
                        System.out.println("Valor deve ser maior do que zero!");
                        }
                    }

                    //getters e setters
                }
            </pre>
            <pre>
                public class ContaPoupanca <span class="pre1">extends Conta </span>{

                    private double taxaDeJuros;

                    public void calcularJuros() {
                        double juros = this.getSaldo() * taxaDeJuros;
                        System.out.println("Juros atual: " +juros);
                    }

                    public void sacar(double valor) {
                        double taxaSaque = 0.01;
                        super.sacar(valor + taxaSaque);
                    }

                    //getters e setters
                }
            </pre>
            <p>No código anterior, a classe Conta é a superclasse e a classe ContaPoupanca é a subclasse. A classe ContaPoupanca herda os atributos e métodos da classe Conta, e adiciona um novo atributo taxaDeJuros e um novo método calcularJuros. Embora os atributos sejam herdados, como eles foram declarados como private na superclasse, não poderão ser acessados diretamente na subclasse, devendo então serem utlizados os métodos getters/setter, que são públicos.</p>
            <p>Repare também no código anterior que a subclasse sobrescreveu o método sacar, para que seja descontada a taxa de saque, além de utilizar a palavra chave super para chamar o método da superclasse, evitando com isso duplicar um código já existente. Essa é a grande vantagem da herança: reaproveitamento de código com flexibilidade para sobrescrever comportamentos.</p>
            <h2>Herança múltipla</h2>
            <p>Em Java, é importante notar que a herança múltipla não é permitida. A herança múltipla ocorre quando uma subclasse herda de duas ou mais superclasses. Por exemplo:</p>
            <pre class="prePropriedade">
                public class ContaPoupanca <span class="pre1">extends Conta, Pagamento</span> {
                    //codigo da classe omitido
                }
            </pre>
            <p><span class="prePropriedade">O código anterior não compila</span>, pois o extends aceita apenas uma única classe, ou seja, uma classe pode ter apenas uma superclasse.</p>
            <p>Entretanto, é possível criar uma hierarquia de classes utilizando herança, simulando com isso uma herança múltipla. Por exemplo:</p>
            <pre>
                public class <span class="pre1">Conta</span> {
                //codigo da classe omitido
                }
            </pre>
            <pre>
                public class <span class="prePropriedade">ContaCorrente</span> <span class="preAmarelo">extends</span> <span class="pre1">Conta</span> {
                //codigo da classe omitido
                }
            </pre>
            <pre>
                public class ContaCorrentePessoaFisica <span class="preAmarelo">extends</span> <span class="prePropriedade">ContaCorrente</span>  {
                //codigo da classe omitido
                }
            </pre>
            <p>No código anterior, a classe ContaCorrentePessoaFisica está herdando de ContaCorrente, que por sua vez herda da classe Conta, ou seja, indiretamente a classe ContaCorrentePessoaFisica vai herdar de Conta, pois sua superclasse herda dela.</p>
        </section>

        <section>
            <h1 class="titulo">Interface</h1>
            <p>Em Java, interfaces são uma forma de definir um contrato que as classes devem seguir, sendo que ele define quais métodos devem ser implementados pelas classes que o implementarem. Interfaces permitem que diferentes classes possam ser tratadas de maneira padronizada, via polimorfismo, tornando assim o código fácil de estender com novos comportamentos.</p>
            <p>No Java, uma interface é definida usando a palavra-chave interface. Por exemplo:</p>
            
            <pre>
                public <span class="preAmarelo">interface</span> Tributavel {

                    double getValorImposto();

                }
            </pre>

            <p>No exemplo de código anterior, estamos definindo uma interface chamada Tributavel, sendo que ela possui apenas um método chamado <span class="codigo">getValorImposto()</span> que retorna um valor do tipo double. Essa interface pode ser implementada por qualquer classe que queira ser tributável no projeto.</p>
            <p>Para implementar uma interface, usamos a palavra-chave implements após a definição da classe. A classe que implementa a interface deve implementar todos os métodos definidos na interface. Por exemplo:</p>

            <pre>
                public class Produto <span class="preAmarelo">implements</span> Tributavel {

                    private String nome;
                    private double valor;

                    @Override
                    public double getValorImposto() {
                        return this.valor * 0.1;
                    }

                    //getters e setters
                }
            </pre>

            <p>No exemplo anterior, estamos criando uma classe chamada Produto que implementa a interface Tributavel. Essa classe implementa o método getValorImposto(), que está definido na interface Tributavel, com uma lógica de que o imposto do produto é igual a 10% do seu valor.</p>
            <p>Também poderíamos ter uma classe de serviços, conforme abaixo:</p>

            <pre>
                public class Servico implements Tributavel {

                    private String descricao;
                    private double valor;
                    private double aliquotaISS;

                    @Override
                    public double getValorImposto() {
                        return this.valor * this.aliquotaISS / 100;
                    }

                    //getters e setters
                }
            </pre>

            <p>No exemplo acima, estamos criando uma classe chamada Servico que implementa a interface Tributavel. Essa classe implementa o método getValorImposto(), que está definido na interface Tributavel, com uma lógica de que o imposto do serviço é igual ao seu valor vezes a alíquota de ISS definida e dividido por 100. Então para um serviço de R$ 1.200,00 e alíquota de 5%, o método retornará: 1200 * 5 / 100, cujo valor do imposto fica R$ 60,00.</p>
            
            <h2>Utilização de interfaces</h2>
            <p>Interfaces podem ser utilizadas para definir comportamentos que podem ser aplicados a várias classes diferentes, tornando assim o código mais modular e fácil de manter.</p>
            <p>Por exemplo, suponha que temos um sistema de vendas que precisa calcular o imposto de diferentes tipos de produtos. Podemos criar a interface Tributavel, para definir o comportamento de calcular imposto, e criar várias classes diferentes que implementam essa interface para calcular o imposto de diferentes produtos. Por exemplo:</p>

            <pre>
                public class CalculadoraImposto {

                    private double totalImposto = 0;

                    public void calcularImposto(Tributavel item) {
                        this.totalImposto += item.getValorImposto();
                    }

                    public double getTotalImposto() {
                    return this.totalImposto;
                    }

                }
            </pre>

            <p>Nesse exemplo, estamos criando uma classe chamada CalculadoraImposto, que tem um atributo privado chamado totalImposto, que armazena o valor total dos impostos. </p>
            <p>Repare que o método calcularImposto recebe um parâmetro do tipo Tributavel. Ao declarar uma variável com o tipo de uma interface, como é feito nesse método, podemos atribuir a essa variável qualquer objeto que implemente essa interface, ou seja, tanto um objeto do tipo Servico quanto Produto. Para ambos os casos, a CalculadoraImposto irá chamar o método implementado na classe específica. Ou seja, para um produto, irá chamar o método getTotalImposto implementado na classe Produto. E para um serviço, irá chamar o método getTotalImposto implementado na classe Servico. </p>
            <p>Isso é muito útil quando queremos tratar vários objetos de classes diferentes de forma semelhante, permitindo que diferentes classes possam ser tratadas de maneira padronizada, facilitando a manutenção e extensão do código. Esse é mais um exemplo de aplicação do polimorfismo em Java, mas agora com a utilização de interfaces.</p>
        </section>
        
        <section>

            <h1 class="titulo">Declarando Variáveis com var</h1>
            <p>A partir da versão 10 do Java, foi adicionada uma nova funcionalidade para a declaração de variáveis chamada var. Essa nova palavra-chave permite que o compilador infira automaticamente o tipo da variável com base no valor atribuído a ela. Isso pode tornar o código mais limpo e legível, além de reduzir a digitação de código redundante.</p>

            <h3>Sintaxe básica</h3>
            <p>A sintaxe básica para declarar uma variável com var é a seguinte:</p>

            <p><strong>var nomeDaVariavel = valorInicial;</strong></p>

            <p>Onde nomeDaVariavel é o nome que você quer dar à variável e valorInicial é o valor que você quer atribuir a ela. O tipo da variável será inferido automaticamente pelo compilador com base no valor atribuído.</p>

            <p>Exemplo:</p>

            <p><strong>var numero = 10;</strong></p>

            <p>Nesse exemplo, a variável numero será inferida como sendo do tipo int, já que o valor atribuído é um número inteiro.</p>

            <h3>Limitações</h3>
            <p>A declaração de variáveis com var possui algumas limitações:</p>

            <p>O tipo da variável deve ser inferido automaticamente pelo compilador. Isso significa que não é possível utilizar var em variáveis cujo tipo não possa ser inferido automaticamente.</p>

            <p>Não é possível usar var em variáveis sem valor inicial. É necessário atribuir um valor à variável na mesma linha em que ela é declarada.</p>
        </section>
        <section>
            <h1 class="titulo">Array</h1>
            <p>Em Java, arrays são estruturas de dados que permitem armazenar uma coleção de elementos do mesmo tipo. Eles são muito utilizados para manipulação de dados em projetos de programação.</p>

            <p>Para declarar um array em Java, é preciso definir seu tipo e tamanho. Por exemplo, para criar um array de inteiros com tamanho 5, podemos escrever o seguinte código:</p>

            <p><strong>int[] numeros = new int[5];</strong></p>

            <p>Aqui, estamos declarando um array chamado "numeros" do tipo "int" e com tamanho 5. É importante lembrar que o índice dos elementos de um array começa em 0 e vai até o tamanho do array menos 1.</p>

            <p>Após declarar um array, podemos inicializá-lo com valores. Por exemplo, podemos preencher o array "numeros" com os números de 1 a 5 da seguinte forma:</p>

            <pre>

                for (int i = 0; i < numeros.length; i++) {
                    numeros[i] = i + 1;
                }
                
            </pre>

            <p>Aqui, estamos percorrendo o array "numeros" utilizando um loop for e preenchendo cada posição com seu respectivo índice mais 1.</p>

            <p>Também é possível criar arrays de objetos e não apenas de tipos primitivos. Por exemplo:</p>

            <pre>

                Filme[] filmes = new Filme[2];
                
                Filme filme1 = new Filme("Avatar", 2009);
                Filme filme2 = new Filme("Dogville", 2003);
                
                filmes[0] = filme1;
                filmes[1] = filme2;
                
            </pre>
            <p>Embora os arrays sejam úteis, eles possuem algumas limitações que podem causar problemas em projetos. Alguns desses problemas incluem:</p>

            <p>Tamanho fixo: o tamanho de um array é fixo e não pode ser alterado após a sua criação. Isso pode ser problemático em situações em que o tamanho dos dados a serem armazenados é desconhecido ou variável.</p>

            <p>Ausência de métodos: arrays não possuem métodos que permitam a inserção, remoção ou pesquisa de elementos de forma eficiente. Isso pode levar a soluções de código complicadas e ineficientes para tarefas simples.</p>

            <p>Justamente por conta desses problemas e dificuldades é que não devemos utilizar arrays para representar uma coleção de elementos, mas sim alguma classe do Java, como a <strong>ArrayList</strong>, que encapsula e abstrai um array, facilitando a sua utilização via métodos e deixando o código do projeto mais simples de entender e evoluir.</p>
        </section>
        <section>
            
            <h1 class="titulo">ArrayList</h1>
            <h2>Criando ArrayList</h2>
            <p class="codigo"><span class="preAmarelo">ArrayList&lt;Filme&gt;</span> listaDeFilmes = new <span class="preAmarelo">ArrayList&lt;&gt;()</span>;</p>
            <h2>Adicionando</h2>
            <p class="codigo">listaDeFilmes.add(filmeDoPaulo);</p>
            <h2>Tamando da Lista</h2>
            <p class="codigo">listaDeFilmes.size();</p>
            <h2>Acessando Objeto</h2>
            <p class="codigo">listaDeFilmes.get(0).getNome();</p>

            <h2>Arrays no Java</h2>
            <p>Em Java, arrays são estruturas de dados que permitem armazenar uma coleção de elementos do mesmo tipo. Eles são muito utilizados para manipulação de dados em projetos de programação.</p>
            <p>Para declarar um array em Java, é preciso definir seu tipo e tamanho. Por exemplo, para criar um array de inteiros com tamanho 5, podemos escrever o seguinte código:</p>
            <p class="codigo">int[] numeros = new int[5];</p>
            <p>Aqui, estamos declarando um array chamado "numeros" do tipo "int" e com tamanho 5. É importante lembrar que o índice dos elementos de um array começa em 0 e vai até o tamanho do array menos 1.</p>
            <p>Após declarar um array, podemos inicializá-lo com valores. Por exemplo, podemos preencher o array "numeros" com os números de 1 a 5 da seguinte forma:</p>
            <pre>
                    for (int i = 0; i < numeros.length; i++) {
                        numeros[i] = i + 1;
                    }
            </pre>
            <p>Aqui, estamos percorrendo o array "numeros" utilizando um loop for e preenchendo cada posição com seu respectivo índice mais 1.</p>
            <p>Também é possível criar arrays de objetos e não apenas de tipos primitivos. Por exemplo:</p>
            <pre>
                Filme[] filmes = new Filme[2];

                Filme filme1 = new Filme("Avatar", 2009);
                Filme filme2 = new Filme("Dogville", 2003);

                filmes[0] = filme1;
                filmes[1] = filme2;
            </pre>
            <p>Embora os arrays sejam úteis, eles possuem algumas limitações que podem causar problemas em projetos. Alguns desses problemas incluem:</p>
            <p>Tamanho fixo: o tamanho de um array é fixo e não pode ser alterado após a sua criação. Isso pode ser problemático em situações em que o tamanho dos dados a serem armazenados é desconhecido ou variável.</p>
            <p>Ausência de métodos: arrays não possuem métodos que permitam a inserção, remoção ou pesquisa de elementos de forma eficiente. Isso pode levar a soluções de código complicadas e ineficientes para tarefas simples.</p>
            <p>Justamente por conta desses problemas e dificuldades é que não devemos utilizar arrays para representar uma coleção de elementos, mas sim alguma classe do Java, como a ArrayList, que encapsula e abstrai um array, facilitando a sua utilização via métodos e deixando o código do projeto mais simples de entender e evoluir.</p>

        </section>
        <section>
            <h1 class="titulo">Construtor</h1>
            <p>Em Java, um construtor é um método especial usado para criar e inicializar um objeto recém-criado. Quando uma classe é definida, ela pode ter um ou mais construtores, sendo que se nenhum construtor for definido explicitamente, o Java criará um construtor default (padrão) automaticamente.</p>
            <p>Um construtor default é um construtor que não possui parâmetros e não executa nenhuma instrução. Ele é chamado sempre que um objeto da classe é criado sem argumentos. Por exemplo:</p>
            <pre>
                public class Pessoa {

                    private String nome;
                    private String email;

                    public Pessoa() {
                    }

                    //metodos getters/setters
                }
            </pre>
            <p>No exemplo de código anterior, a classe Pessoa possui um construtor default, que será exatamente o mesmo construtor que o Java criará automaticamente, caso nenhum construtor tivesse sido definido na classe.</p>
            <p>Se uma classe define explicitamente um ou mais construtores, mas não define um construtor sem parâmetros, então não há construtor default. Nesse caso, se um objeto é criado sem argumentos, um erro de compilação será gerado.</p>
            <p>É importante ressaltar que mesmo que um construtor default possa ser útil em alguns casos, é sempre recomendável definir explicitamente os construtores da classe, especialmente se a classe tiver atributos que precisam ser inicializados com valores específicos ou obrigatórios. Isso também torna o código mais claro e fácil de entender.</p>
        </section>
        <section>
            <h1 class="titulo">Formas de Percorrer Listas</h1>
            <p>A forma mais comum de percorrer uma lista no Java é utilizando o laço foreach tradicional, também conhecido como for-each. Esse laço permite que se percorra todos os elementos de uma lista, sem a necessidade de se preocupar com índices ou o tamanho dela, tornando o código mais simples e legível. Por exemplo, suponha que tenhamos uma lista de nomes de pessoas e que desejamos imprimi-los na tela:</p>
            <pre>
                ArrayList&lt;String&gt; nomes = new ArrayList<>();
                nomes.add("Jacqueline");
                nomes.add("Paulo");
                nomes.add("Suellen");
                nomes.add("Emily");

                for (String nome : nomes) {
                    System.out.println(nome);
                }                
            </pre>
            <p>Esse loop for percorre todos os elementos da lista, atribuindo cada um deles à variável nome, que é usada para imprimir o valor na tela. Esse tipo de loop é muito útil em situações onde não precisamos realizar nenhuma operação complexa sobre os elementos da lista.</p>
            <p>No entanto, a partir do Java 8, foi adicionado na interface List, a qual a classe ArrayList implementa, um novo método chamado forEach, que possibilita a iteração sobre os elementos da lista de forma mais concisa e elegante. Por exemplo, o exemplo anterior pode ser reescrito utilizando o método forEach da seguinte forma:</p>
            <p class="codigo">nomes.forEach(nome -> System.out.println(nome));</p>
            <p>Nesse caso, o método forEach é chamado sobre a lista nomes e recebe como parâmetro uma expressão lambda que realiza a impressão do valor na tela. A expressão lambda nome -> System.out.println(nome) é uma forma compacta de definir uma função que recebe um parâmetro nome e realiza a operação de impressão.</p>
            <p>É possível simplificar ainda mais o exemplo de código anterior, utilizando o recurso conhecido como Method Reference, que nada mais é do que uma forma reduzida de uma expressão lambda:</p>
            <p class="codigo">nomes.forEach(System.out::println);</p>
            <p>No código anterior, o símbolo :: é a sintaxe do Method Reference, que no exemplo mostrado faz uma referência para o método println.</p>
        </section>
        <section>
            <h1 class="titulo">Variáveis e referências</h1>
            <p>Referências são ponteiros para objetos em memória, ou seja, elas apontam para um objeto e permitem que você trabalhe com ele. No Java, toda variável de objeto é na verdade uma referência a esse objeto que foi alocado na memória. </p>
            <p>Quando você instancia um objeto, está, na realidade, criando um novo bloco de memória que armazena as informações desse objeto. A maneira de chegar a esse bloco de memória, para armazenar e ler informações dele, ocorre por meio de uma referência, que é representada por uma variável. Por exemplo:</p>
            <p class="codigo">Filme filme1 = new Filme("Avatar", 2009);</p>
            <p>No exemplo de código anterior, criamos um novo objeto da classe Filme e armazenamos uma referência a ele na variável filme1.</p>
            <p>É importante lembrar que as referências a objetos em Java não são o próprio objeto em si, pois elas apenas apontam para o objeto. Quando você passa uma referência a um método ou atribui uma referência a outra variável, está apenas copiando o valor da referência e não do objeto em si. Por exemplo:</p>
            <pre>
                Filme filme1 = new Filme("Avatar", 2009);
                Filme filme2 = new Filme("The Matrix", 1999);
                Filme filme3 = filme1;
            </pre>
            <p>No exemplo de código anterior, foram criados apenas dois objetos em memória. A variável filme3 é apenas uma referência que aponta para o mesmo objeto sendo referenciado pela variável filme1.</p>
            <p>Uma questão importante relacionada com referências a objetos em Java é a questão da igualdade e identidade de objetos. Quando você compara duas referências de objeto usando o operador de igualdade ==, está comparando as referências em si, não os objetos que elas apontam. Por exemplo:</p>
            <pre>
                Filme filme1 = new Filme("Avatar", 2009);
                Filme filme2 = new Filme("Avatar", 2009);

                if (filme1 == filme2) {
                    System.out.println("Iguais");
                } else {
                    System.out.println("Diferentes");
                }
            </pre>
            <p>No exemplo de código anterior, a saída no console será: "Diferentes". Embora os dois objetos tenham as mesmas informações na memória, a comparação com == verifica se as referências são iguais, ou seja, se apontam para o mesmo objeto na memória.</p>
        </section>
        <section>
            <h1 class="titulo">Utilizando Collections.sort para ordenar listas</h1>
            <pre>
                ArrayList<String> buscaPorArtista = new ArrayList<>();
                buscaPorArtista.add("Adam Sandler");
                buscaPorArtista.add("Paulo");
                buscaPorArtista.add("Jacqueline");
                System.out.println(buscaPorArtista);

                Collections.sort(buscaPorArtista);
                System.out.println("Depois da ordenação");
                System.out.println(buscaPorArtista);
            </pre>
            <p>Para utilizar o Collections.sort a classe precisa inplementar a interface <strong>Comparable</strong> no caso das variáveis primitivas e o objeto String as classes já implementam esta interface, porém as classes que não tiverem esta interface, precisamos implementa-la.</p>
            <h2>Implementando a interface Comparable</h2>
            <p>Primeiro instanciamos a interface Comparable na classe</p>
            <p class="codigo">public class Titulo implements Comparable&lt;Titulo&gt;{...}</p>
            <p>Depois precisamos criar o método da interface que é o compareTo</p>
            <pre>
                @Override
                public int compareTo(Titulo outroTitulo) {
                    return this.getNome().compareTo(outroTitulo.getNome());
                }
            </pre>
            <p>Agora podemos utilizar o Collections.sort em nossa lista de objetos</p>
            <p class="codigo">Collections.sort(lista);</p>
            <p>Se quisermos ordenar utilizando outros métodos de comparação:</p>
            <p class="codigo">lista.sort(Comparator.comparing(Titulo::getAnoDeLancamento));</p>
            
        </section>
        <section>
            <h1 class="titulo">Outras classes de listas no Java</h1>
            <p>O Java oferece diferentes classes para representar uma lista de objetos. Essas classes são úteis em diferentes cenários, dependendo das necessidades de cada aplicação.</p>
            <p>As classes mais comuns para representar uma lista no Java são:</p>
            <h2>ArrayList</h2>
            <p>A principal característica do ArrayList é que ele é baseado em um array dinâmico. Ele armazena os elementos em uma matriz interna e, conforme novos elementos são adicionados, o tamanho da matriz é automaticamente ajustado para acomodar o novo elemento. Da mesma forma, quando um elemento é removido, o tamanho do array é ajustado para evitar o desperdício de espaço. O ArrayList é amplamente utilizado devido à sua facilidade de uso e eficiência em termos de desempenho.</p>
            <h2>LinkedList</h2>
            <p>A classe LinkedList fornece uma lista encadeada de elementos. Diferentemente do ArrayList, que é baseado em um array, o LinkedList é baseado em uma lista encadeada, o que significa que cada elemento da lista é um objeto que contém uma referência para o próximo elemento. Isso permite que os elementos sejam adicionados e removidos de maneira eficiente em qualquer posição da lista, mas pode tornar a pesquisa de um elemento específico menos eficiente./p>
            <p>O LinkedList é uma boa escolha quando a inserção e remoção de elementos em qualquer posição da lista é frequente e quando não é necessário acessar os elementos de forma aleatória.</p>
            <h2>Vector</h2>
            <p>A classe Vector é semelhante ao ArrayList, mas é sincronizada, o que significa que é segura para uso em threads concorrentes. No entanto, a sincronização adiciona uma sobrecarga de desempenho, então o Vector pode ser mais lento que o ArrayList em algumas situações.</p>
            <h2>Stack</h2>
            <p>A classe Stack implementa uma pilha, que é uma coleção ordenada de elementos onde a inserção e remoção de elementos ocorrem sempre no mesmo extremo da lista. Os elementos são adicionados e removidos em uma ordem conhecida como "last-in, first-out" (LIFO), ou seja, o último elemento adicionado é o primeiro a ser removido. A classe Stack é usada com frequência em algoritmos de processamento de texto, bem como em outras situações em que a LIFO é a maneira natural de organizar os dados.</p>
            <p>Cada uma dessas classes tem seus próprios pontos fortes e fracos, e a escolha de qual usar dependerá das necessidades específicas da aplicação. Para um melhor entendimento sobre estruturas de dados, recomendamos a leitura dos seguintes artigos:</p>
        </section>
        <section>
            <h1 class="titulo">Map e HashMap</h1>
            <p>Uma das características mais importantes do Java é sua vasta biblioteca padrão, que oferece muitas classes e interfaces úteis para os desenvolvedores. Entre elas, estão o Map e o HashMap, que são ferramentas essenciais para associação de chaves e valores em muitas aplicações Java.</p>
            <h2>Map</h2>
            <p>O Map é uma interface que permite que os desenvolvedores associem chaves a valores. É uma estrutura de dados útil para muitas aplicações Java, especialmente aquelas que envolvem a manipulação de grandes quantidades de dados, portanto, é comum usá-lo para realizar buscas, atualização e recuperação de elementos por chaves</p>
            <p>Ele é implementado por diversas classes, sendo a mais comum delas o HashMap.</p>
            <h2>HashMap</h2>
            <p>O HashMap é uma classe que implementa a interface Map usando uma tabela hash para armazenar os pares chave-valor. Ele é conhecido por sua eficiência em termos de tempo de execução. Essa classe tem uma complexidade de tempo O(1) - constante - para inserção, recuperação e remoção de elementos. Isso significa que o desempenho do HashMap não depende do tamanho da coleção de dados! </p>
            <p>No entanto, é importante lembrar que o HashMap não mantém a ordem de inserção dos elementos e não garante a ordem dos elementos na saída. Isso ocorre porque a ordem dos elementos depende da função de hash usada para mapear as chaves para índices na tabela hash. Além disso, o desempenho do HashMap pode ser afetado se houver muitas colisões de hash entre as chaves.</p>
            <p>Por exemplo:</p>
            <pre>
                import java.util.HashMap;
                import java.util.Map;

                public class ExemploHashMap {

                    public static void main(String[] args) {
                        //Criando um objeto da classe HashMap que implementa a interface Map
                        Map<String, Integer> usandoHashMap = new HashMap<>();

                        // Adicionando pares chave-valor
                        usandoHashMap.put("Gatos", 1);
                        usandoHashMap.put("Cachorros", 2);
                        usandoHashMap.put("Roedores", 3);

                        // Acessando um valor através de uma chave
                        int valor = usandoHashMap.get("Cachorros");
                        System.out.println("Valor da chave Cachorros: " + valor);

                        // Removendo um par chave-valor
                        usandoHashMap.remove("Gatos");

                        // Iterando sobre as chaves
                        for (String chave : usandoHashMap.keySet()) {
                            System.out.println("Chave: " + chave);
                            System.out.println("Valor: " + usandoHashMap.get(chave));
                        }
                    }
                }
            </pre>
            <p>O resultado será:</p>
            <pre>
                Valor da chave Cachorros: 2
                Chave: Cachorros
                Valor: 2
                Chave: Roedores
                Valor: 3
            </pre>
        </section>
        <section>
            <h1 class="titulo">HttpRequest</h1>
            <pre>
                public static void main (String[] args) throws IOException, InterruptedException {
                    HttpClient client = HttpClient.newHttpClient();
                    <span class="pre1">HttpRequest</span> request = HttpRequest.newBuilder()
                            .uri(URI.create("https://www.omdbapi.com/?t=matrix&apikey=77149450"))
                            .build();
                }
            </pre>
            <h1 class="titulo">HttpResponse</h1>
            <pre>
                <span class="pre1">HttpResponse</span>&lt;String&gt; response = client
                                .send(request, HttpResponse.BodyHandlers.ofString());

                System.out.println(response.body());
            </pre>
        </section>
                <section>
            <h1 class="titulo">Adicionando Biblioteca manualmente</h1>
            <section>
                <p>Primeiro acessar o site MVN Repository <a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
                <p>Pesquisar Gson</p>
                <p>Acessar a biblioteca Gson</p>
                <p>Selecionar uma versão sem vulnerabilidade</p>
                <p>Clicar em Jar que esta em files, para baixar o arquivo jar</p>
                <p>Agora no IntelliJ</p>
                <figure>
                    <img src="IMG/java/1.png" alt="Project Structure">
                    <figcaption>clicar em file e depois em Project Structure</figcaption>
                </figure>
                <figure>
                    <img src="IMG/java/2.png" alt="Dependencies">
                    <figcaption>Ir em Project Settings > Modules > Dependencies</figcaption>
                </figure>
                <figure>
                    <img src="IMG/java/3.png" alt="Adicionando Arquivo">
                    <figcaption>Clicar em + para adicionar o arquivo e depois em ok</figcaption>
                </figure>
                <p>Agora basta colocar:</p>
                <p class="codigo">Gson gson = new Gson();</p>
            </section>
        </section>
        <section>
            <h1 class="titulo">Bibliotecas e Frameworks</h1>
            <p>Bibliotecas e frameworks em Java, e também em outras linguagens de programação, são ferramentas essenciais para quem trabalha com programação, pois ajudam a reduzir a quantidade de trabalho necessária para construir aplicações, uma vez que fornecem funcionalidades prontas para uso, permitindo que as pessoas desenvolvedoras foquem na lógica de negócios dos projetos, ao invés de se preocuparem com problemas técnicos que são comuns e já possuem soluções prontas para uso.</p>
            <p>Em Java, bibliotecas são coleções de classes e interfaces que oferecem uma série de recursos e funcionalidades prontas para uso. Geralmente elas são distribuídas como arquivos JAR (Java Archive), que são pacotes de arquivos Java que contém classes e outros recursos, como imagens e arquivos de configuração. As bibliotecas podem ser importadas em projetos Java e usadas diretamente em código para implementar funcionalidades específicas, como manipulação de arquivos, conexão com bancos de dados, criptografia, etc.</p>
            <p>Frameworks, por outro lado, são estruturas de software que fornecem uma arquitetura básica para o desenvolvimento de aplicações. Eles incluem bibliotecas, padrões e práticas recomendadas para orientar o processo de desenvolvimento de aplicações. Um framework pode ser considerado como uma "fábrica padronizada de aplicações", que fornece os componentes necessários para criar uma aplicação, bem como um conjunto de regras e diretrizes para guiá-lo no processo.</p>
            <p>Existem muitos frameworks populares em Java, cada um com suas próprias características e objetivos. Alguns exemplos incluem o Spring Framework, que é um framework que facilita a criação de aplicações Web e APIs Rest complexas em Java; o Hibernate, que é um framework de mapeamento objeto-relacional e simplifica muito o processo de integração de uma aplicação Java com um banco de dados relacional.</p>
        </section>
    </main>
    
</body>
</html>