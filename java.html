<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/java.css">
    <title>Java Anotações</title>
</head>
<body>
    <nav>
        <ul>
            <li class="link"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/index.html">Documentação Java</a></li>
            <li class="link"><a href="https://www.alura.com.br/apostila-java-orientacao-objetos">Apostila Java</a></li>
            <li class="link"><a href="https://www.alura.com.br/artigos/poo-programacao-orientada-a-objetos">Artigo sobre POO</a></li>
            <li class="link"><a href="https://www.alura.com.br/artigos/ordenando-colecoes-com-comparable-e-comparator">Artigo Ordenando Listas</a></li>
            <li class="link"><a href="https://www.alura.com.br/artigos/estruturas-de-dados-introducao">Artigo Estruturas de dados: uma introdução</a></li>
            <li class="link"><a href="https://www.alura.com.br/artigos/estrutura-dados-computacao-na-pratica-com-java">Artigo Estrutura de Dados: computação na prática com Java</a></li>
            <li class="link"><a href="https://www.alura.com.br/podcast/hipsterstech-algoritmos-e-estrutura-de-dados-hipsters-186-a375">Podcast  Algoritmos e estrutura de dados - Hipsters #186 </a></li>
            <li class="link"><a href="https://www.alura.com.br/artigos/estruturas-de-dados-introducao">Artigo Estruturas de dados: uma introdução</a></li>
            <li class="link"><a href="https://www.linkedin.com/pulse/exce%C3%A7%C3%B5es-em-java-uma-primeira-conversa-vanessa/">Artigo:Exceções em Java: Uma Primeira Conversa</a></li>
            <li class="link"><a href="https://pt.wikibooks.org/wiki/Java/Exce%C3%A7%C3%B5es">Java/Exceções Wiki</a></li>
            <li class="link"><a href="https://dev.to/dearrudam/be-the-exception-dicas-para-dominar-excecoes-em-seus-codigos-java-4nlo">Dicas para dominar exceções em seus códigos Java </a></li>
            <li class="link"><a href="https://www.youtube.com/watch?v=TUBqH9zVs3M">youtube: Guia da carreira Java</a></li>
            <li class="link"><a href="https://www.alura.com.br/artigos/foreach-java">Artigo: ForEach Java</a></li>
        </ul>
    </nav>
    <nav>
        <ul>
            <li class="link"><a href="https://mvnrepository.com/">MVN Repository</a></li>
            <li class="link"><a href="https://omdbapi.com/">API OMDb - banco de dados de filmes abertos</a></li>
        </ul>
    </nav>
    <nav>
        <h1 class="titulo">Cursos</h1>
        <ul>
            <li class="link"><a href="https://cursos.alura.com.br/course/introducao-design-patterns-java">Design Patterns em Java I: boas práticas de programação</a></li>
            <li class="link"><a href="https://cursos.alura.com.br/course/avancando-design-patterns-java">Design Patterns em Java II: avançando nas boas práticas de programação</a></li>
        </ul>
    </nav>
    <main>
        <section>
            <h1 class="titulo">Formatação de texto</h1>
            <p>Em Java, é possível formatar textos e números de diversas maneiras. Isso pode ser útil em diversas situações, como ao exibir valores para o usuário de uma maneira mais legível.</p>
            <p>Uma das maneiras mais comuns de se formatar textos em Java é utilizando o método format(), da classe String. Esse método permite formatar um texto utilizando diversos placeholders, que são representados pelo caractere % seguido de uma letra que indica o tipo de dado que será inserido no placeholder. Por exemplo, %s indica que uma String será inserida no placeholder, %d indica um valor inteiro e %f indica um valor de ponto flutuante. Vamos ver um exemplo:</p>

            <Pre>

                String nome = "Maria";
                int idade = 30;
                double valor = 55.9999;
                System.out.println(String.format("Meu nome é %s, eu tenho %d anos e hoje gastei %.2f reais", nome, idade, valor));

            </Pre>

            <p>Nesse exemplo, os valores das variáveis nome, idade e valor são passados como parâmetros para o método String.format, substituindo os placeholders %s, %d e %.2f, respectivamente. O resultado impresso será "Meu nome é Maria, eu tenho 30 anos e hoje gastei 55,99 reais". Perceba também que o placeholder %.2f indica que o valor deve ser formatado com duas casas decimais.</p>
            <p>Esse exemplo do que foi feito para o String.format também pode ser usado com Text Block, onde usa-se o método que citei em aula, o formatted, para informar as variáveis que deverão ser utilizadas no lugar dos placeholders. Veja esse exemplo:</p>

            <pre>

                String nome = "João";
                int aulas = 4;
                
                String mensagem = """
                Olá, %s!
                Boas vindas ao curso de Java.
                Teremos %d aulas para te mostrar o que é preciso para você dar o seu primeiro mergulho na linguagem!
                """.formatted(nome, aulas);
                
                System.out.println(mensagem);
                Copiar código
                O resultado impresso será:
                
                Olá, João!
                
                Boas vindas ao curso de Java.
            </pre>
        </section>
        <section>
            <h1 class="titulo">Tipos Primitivos em Java</h1>
            
            <h3>boolean</h3>
            <p>O tipo boolean é utilizado para representar valores lógicos, podendo assumir apenas dois valores: true ou false. É utilizado em expressões condicionais, loops e outros casos onde se deseja avaliar se uma determinada condição é verdadeira ou falsa.</p>
            
            <h3>byte</h3>
            <p>O tipo byte é utilizado para representar valores numéricos inteiros de 8 bits. Ele possui uma faixa de valores de -128 a 127.</p>

            <h3>char</h3>
            <p>O tipo char é utilizado para representar caracteres individuais. Ele pode armazenar qualquer caractere Unicode e é representado por aspas simples ('').</p>

            <h3>short</h3>
            <p>O tipo short é utilizado para representar valores numéricos inteiros de 16 bits. Ele possui uma faixa de valores de -32.768 a 32.767.</p>

            <h3>int</h3>
            <p>O tipo int é utilizado para representar valores numéricos inteiros de 32 bits. É um dos tipos de dados mais utilizados para representar números inteiros em Java e possui uma faixa de valores de -2.147.483.648 a 2.147.483.647.</p>

            <h3>long</h3>
            <p>O tipo long é utilizado para representar valores numéricos inteiros de 64 bits. Ele é utilizado para representar valores inteiros muito grandes e possui uma faixa de valores de -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807.</p>

            <h3>float</h3>
            <p>O tipo float é utilizado para representar valores numéricos de ponto flutuante, ou seja, valores com casas decimais, sendo que ocupa 32 bits de memória. Ele pode representar números decimais com até sete dígitos e tem uma precisão limitada, o que significa que ele pode arredondar os números se eles forem muito grandes ou muito pequenos.</p>

            <h3>double</h3>
            <p>O tipo double é similar o float, entretanto ele ocupa 64 bits de memória e pode representar números decimais com até 15 dígitos.</p>
        </section>
        <section>
            <h1 class="titulo">Utilizando Scanner</h1>
            <pre>

                public class ExemploScanner {
                    public static void main(String[] args) {
                        Scanner scanner = new Scanner(System.in);
                        
                        System.out.print("Digite seu nome: ");
                        String nome = scanner.nextLine();
                        System.out.print("Digite sua idade: ");
                        int idade = scanner.nextInt();
                        System.out.print("Digite o valor que pretende investir esse mês: ");
                        double valor = scanner.nextDouble();
                        
                        System.out.println(nome + " que tem " + idade + " anos, irá investir R$ " + valor + " esse mês.");
                        
                        scanner.close();
                    }
                }
            </pre>

            <h2>Erro fantasma no scanner</h2>
            <p>Quando você usa nextDouble() (ou nextInt()), o Scanner lê apenas o número. O caractere de "quebra de linha" (\n), que é gerado quando você aperta Enter, continua parado no "buffer" (a memória temporária do teclado).</p>
            <p>Na próxima vez que o código executa o nextLine(), ele encontra esse \n sobrando, acha que você enviou uma linha vazia e "pula" a leitura da descrição, indo direto para o próximo nextDouble().</p>
            <p>Muitos programadores preferem ler tudo com nextLine() e converter para o número depois. Isso evita qualquer confusão com o buffer.</p>
            <p class="codigo">double valor = Double.parseDouble(scanner.nextLine());</p>
        </section>
        <section>
            <h1 class="titulo">Utilizando for</h1>
            <pre>

                import java.util.Scanner;
                
                public class Loop {
                    public static void main(String[] args) {
                        Scanner leitura = new Scanner(System.in);
                        double mediaAvaliacao = 0;
                        double nota = 0;
                        
                        for (int i = 0; i < 3; i++) {
                            System.out.println("Diga sua avaliação para o filme  ");
                            nota = leitura.nextDouble();
                            mediaAvaliacao += nota;
                        }
                        
                        System.out.println("Média de avaliações " + mediaAvaliacao/3);
                        
                    }
                }
            </pre>
        </section>
        <section>
            <h1 class="titulo">Utilizando While</h1>
            <pre>

                import java.util.Scanner;
                
                public class OutroLoop {
                    public static void main(String[] args) {
                        Scanner leitura = new Scanner(System.in);
                        double mediaAvaliacao = 0;
                        double nota = 0;
                        int totalDeNotas = 0;
                        
                        while (nota != -1) {
                        System.out.println("Diga sua avaliação para o filme ou -1 para encerrar  ");
                        nota = leitura.nextDouble();
                        
                        if (nota != -1) {
                            mediaAvaliacao +=  nota;
                            totalDeNotas++;
                        }
                        
                    }
                    
                    System.out.println("Média de avaliações " + mediaAvaliacao / totalDeNotas);
                }
            }
            </pre>
        </section>
        <section>
            <h1 class="titulo">construtor padrão</h1>

            <p>Em Java, um construtor é um método especial usado para criar e inicializar um objeto recém-criado. Quando uma classe é definida, ela pode ter um ou mais construtores, sendo que se nenhum construtor for definido explicitamente, o Java criará um construtor default (padrão) automaticamente.</p>

            <p>Um construtor default é um construtor que não possui parâmetros e não executa nenhuma instrução. Ele é chamado sempre que um objeto da classe é criado sem argumentos. Por exemplo:</p>
            <pre>
                public class Pessoa {
                    
                    private String nome;
                    private String email;
                    
                    public Pessoa() {
                    }
                    
                    //metodos getters/setters
                }
            </pre>

            <p>No exemplo de código anterior, a classe Pessoa possui um construtor default, que será exatamente o mesmo construtor que o Java criará automaticamente, caso nenhum construtor tivesse sido definido na classe.</p>

            <p>Se uma classe define explicitamente um ou mais construtores, mas não define um construtor sem parâmetros, então não há construtor default. Nesse caso, se um objeto é criado sem argumentos, um erro de compilação será gerado.</p>

            <p>É importante ressaltar que mesmo que um construtor default possa ser útil em alguns casos, é sempre recomendável definir explicitamente os construtores da classe, especialmente se a classe tiver atributos que precisam ser inicializados com valores específicos ou obrigatórios. Isso também torna o código mais claro e fácil de entender.</p>
        </section>

        <section>

            <h1 class="titulo">Modificadores de Acesso</h1>
            <p>Em Java, os modificadores de acesso são palavras-chave que definem o nível de visibilidade de classes, atributos e métodos, sendo que eles ajudam a garantir a segurança e encapsulamento do código.</p>
            <p>Existem quatro tipos de modificadores de acesso em Java: public, protected, private e default (também conhecido como package-private).</p>
            
            <h2>Public</h2>
            <p>O modificador de acesso public é o mais permissivo de todos. Uma classe, atributo ou método declarado como public pode ser acessado por qualquer classe em qualquer pacote. Ou seja, ele possui visibilidade pública e pode ser utilizado livremente. Por exemplo:</p>
            <pre>
                <span class="pre1">public</span> class Conta {

                    <span class="pre1">public</span> double saldo;

                    <span class="pre1">public</span> void sacar(double valor) {
                        // lógica de saque...
                    }
                }
            </pre>
            
            <h2>Default (Package-private)</h2>
            <p>O modificador de acesso default é aquele que não especifica nenhum modificador de acesso. Quando nenhum modificador de acesso é especificado, a classe, atributo ou método pode ser acessado apenas pelas classes que estão no mesmo pacote. Por exemplo:</p>
            <pre>
                package br.com.alura.conta;

                public class Conta {

                    double saldo;

                    void sacar(double valor) {
                        // lógica de saque...
                    }
                }
            </pre>
            <pre>
                package br.com.alura.testes;

                public class Principal {
                    
                    public static void main(String[] args) {
                        Conta c1 = new Conta();
                        c1.saldo = 300;
                        c1.sacar(100);
                    }

                }
            </pre>
            <p>No código anterior, a classe Conta está em um pacote e a classe Principal em outro pacote distinto. A classe Conta pode ser instanciada dentro da classe Principal, pois ela possui o modificador de acesso public, entretanto, o atributo saldo e o método sacar tem o modificador default e, portanto, não podem ser acessados de dentro da classe Principal, o que vai causar um erro de compilação no código anterior.</p>
            
            <h2>Private</h2>
            <p>O modificador de acesso private é o mais restritivo de todos. Uma classe, atributo ou método declarado como private só pode ser acessado dentro da própria classe. Ou seja, ele possui visibilidade restrita e não pode ser utilizado por outras classes. Por exemplo:</p>
            <pre>
                public class Conta {

                    <span class="pre1">private</span> double saldo;

                    <span class="pre1">private</span> void sacar(double valor) {
                        // lógica de saque...
                    }
                }
            </pre>

            <h2>Protected</h2>
            <p>Ao usar herança no Java, temos a possibilidade de utilizar o modificador de acesso protected, que permite que os atributos de uma classe sejam acessados por outras classes do mesmo pacote e também por suas subclasses, independentemente do pacote em que se encontram.</p>
            <p>O modificador protected é útil em situações em que uma classe precisa permitir que suas subclasses acessem diretamente seus atributos, sem a necessidade de restringir o acesso apenas pelos métodos getters e setters. Por exemplo, suponha que temos as seguintes classes em um projeto:</p>

            <pre>
                public class Conta {

                    private String titular;
                    private double saldo;

                    public void sacar(double valor) {
                        //implementacao do metodo omitida
                    }

                    public void depositar(double valor) {
                        //implementacao do metodo omitida
                    }

                    //getters e setters
                }
            </pre>
            <pre>
                public class ContaPoupanca extends Conta {

                    private double taxaDeJuros;

                    public void calcularJuros() {
                        double juros = this.getSaldo() * taxaDeJuros;
                        System.out.println("Juros atual: " +juros);
                    }

                    //getters e setters
                }
            </pre>
            <p>No código anterior, repare que no método calcularJuros, da classe ContaPoupanca, o atributo saldo não é acessado diretamente, pois ele foi declarado como private na classe Conta, devendo então seu acesso ser feito pelo método getSaldo().</p>
            <p>Podemos declarar o atributo saldo como protected, para evitar essa situação e liberar o acesso direto a ele pelas classes que herdam da classe Conta:</p>
            <pre>
                public class Conta {

                    private String titular;
                    protected double saldo;

                    public void sacar(double valor) {
                        //implementacao do metodo omitida
                    }

                    public void depositar(double valor) {
                        //implementacao do metodo omitida
                    }

                    //getters e setters
                }
            </pre>
            <pre>
                public class ContaPoupanca extends Conta {

                    private double taxaDeJuros;

                    public void calcularJuros() {
                        double juros = this.saldo * taxaDeJuros;
                        System.out.println("Juros atual: " +juros);
                    }

                    //getters e setters
                }
            </pre>
            <p>Repare que agora o atributo saldo foi acessado diretamente pela classe ContaPoupanca.</p>
            
        </section>
        <section>

            <h1 class="titulo">Herança</h1>
            <p>A herança é um conceito fundamental da orientação a objetos, sendo implementada em Java através da relação é um entre classes. Isso significa que uma classe pode herdar atributos e métodos de outra classe, tornando com isso o código mais reutilizável.</p>
            <p>No Java, a herança é realizada através da palavra-chave extends. A classe que herda é chamada de subclasse, e a classe que é herdada é chamada de superclasse. A subclasse pode acessar todos os atributos e métodos públicos e protegidos da superclasse, além de poder sobrescrever os métodos da superclasse para criar comportamentos específicos.</p>
            <p>Por exemplo:</p>
            <pre>
                public class Conta {

                    private String titular;
                    private double saldo;

                    public void sacar(double valor) {
                        if (valor <= 0) {
                        System.out.println("Valor deve ser maior do que zero!");
                        } else if (saldo >= valor) {
                        saldo -= valor;
                        System.out.println("Saque realizado com sucesso. Saldo atual: " +saldo);
                        } else {
                        System.out.println("Saldo insuficiente.");
                        }
                    }

                    public void depositar(double valor) {
                        if (valor > 0) {
                        saldo += valor;
                        System.out.println("Depósito realizado com sucesso. Saldo atual: " +saldo);
                        } else {
                        System.out.println("Valor deve ser maior do que zero!");
                        }
                    }

                    //getters e setters
                }
            </pre>
            <pre>
                public class ContaPoupanca <span class="pre1">extends Conta </span>{

                    private double taxaDeJuros;

                    public void calcularJuros() {
                        double juros = this.getSaldo() * taxaDeJuros;
                        System.out.println("Juros atual: " +juros);
                    }

                    public void sacar(double valor) {
                        double taxaSaque = 0.01;
                        super.sacar(valor + taxaSaque);
                    }

                    //getters e setters
                }
            </pre>
            <p>No código anterior, a classe Conta é a superclasse e a classe ContaPoupanca é a subclasse. A classe ContaPoupanca herda os atributos e métodos da classe Conta, e adiciona um novo atributo taxaDeJuros e um novo método calcularJuros. Embora os atributos sejam herdados, como eles foram declarados como private na superclasse, não poderão ser acessados diretamente na subclasse, devendo então serem utlizados os métodos getters/setter, que são públicos.</p>
            <p>Repare também no código anterior que a subclasse sobrescreveu o método sacar, para que seja descontada a taxa de saque, além de utilizar a palavra chave super para chamar o método da superclasse, evitando com isso duplicar um código já existente. Essa é a grande vantagem da herança: reaproveitamento de código com flexibilidade para sobrescrever comportamentos.</p>
            <h2>Herança múltipla</h2>
            <p>Em Java, é importante notar que a herança múltipla não é permitida. A herança múltipla ocorre quando uma subclasse herda de duas ou mais superclasses. Por exemplo:</p>
            <pre class="prePropriedade">
                public class ContaPoupanca <span class="pre1">extends Conta, Pagamento</span> {
                    //codigo da classe omitido
                }
            </pre>
            <p><span class="prePropriedade">O código anterior não compila</span>, pois o extends aceita apenas uma única classe, ou seja, uma classe pode ter apenas uma superclasse.</p>
            <p>Entretanto, é possível criar uma hierarquia de classes utilizando herança, simulando com isso uma herança múltipla. Por exemplo:</p>
            <pre>
                public class <span class="pre1">Conta</span> {
                //codigo da classe omitido
                }
            </pre>
            <pre>
                public class <span class="prePropriedade">ContaCorrente</span> <span class="preAmarelo">extends</span> <span class="pre1">Conta</span> {
                //codigo da classe omitido
                }
            </pre>
            <pre>
                public class ContaCorrentePessoaFisica <span class="preAmarelo">extends</span> <span class="prePropriedade">ContaCorrente</span>  {
                //codigo da classe omitido
                }
            </pre>
            <p>No código anterior, a classe ContaCorrentePessoaFisica está herdando de ContaCorrente, que por sua vez herda da classe Conta, ou seja, indiretamente a classe ContaCorrentePessoaFisica vai herdar de Conta, pois sua superclasse herda dela.</p>
        </section>

        <section>
            <h1 class="titulo">Interface</h1>
            <p>Em Java, interfaces são uma forma de definir um contrato que as classes devem seguir, sendo que ele define quais métodos devem ser implementados pelas classes que o implementarem. Interfaces permitem que diferentes classes possam ser tratadas de maneira padronizada, via polimorfismo, tornando assim o código fácil de estender com novos comportamentos.</p>
            <p>No Java, uma interface é definida usando a palavra-chave interface. Por exemplo:</p>
            
            <pre>
                public <span class="preAmarelo">interface</span> Tributavel {

                    double getValorImposto();

                }
            </pre>

            <p>No exemplo de código anterior, estamos definindo uma interface chamada Tributavel, sendo que ela possui apenas um método chamado <span class="codigo">getValorImposto()</span> que retorna um valor do tipo double. Essa interface pode ser implementada por qualquer classe que queira ser tributável no projeto.</p>
            <p>Para implementar uma interface, usamos a palavra-chave implements após a definição da classe. A classe que implementa a interface deve implementar todos os métodos definidos na interface. Por exemplo:</p>

            <pre>
                public class Produto <span class="preAmarelo">implements</span> Tributavel {

                    private String nome;
                    private double valor;

                    @Override
                    public double getValorImposto() {
                        return this.valor * 0.1;
                    }

                    //getters e setters
                }
            </pre>

            <p>No exemplo anterior, estamos criando uma classe chamada Produto que implementa a interface Tributavel. Essa classe implementa o método getValorImposto(), que está definido na interface Tributavel, com uma lógica de que o imposto do produto é igual a 10% do seu valor.</p>
            <p>Também poderíamos ter uma classe de serviços, conforme abaixo:</p>

            <pre>
                public class Servico implements Tributavel {

                    private String descricao;
                    private double valor;
                    private double aliquotaISS;

                    @Override
                    public double getValorImposto() {
                        return this.valor * this.aliquotaISS / 100;
                    }

                    //getters e setters
                }
            </pre>

            <p>No exemplo acima, estamos criando uma classe chamada Servico que implementa a interface Tributavel. Essa classe implementa o método getValorImposto(), que está definido na interface Tributavel, com uma lógica de que o imposto do serviço é igual ao seu valor vezes a alíquota de ISS definida e dividido por 100. Então para um serviço de R$ 1.200,00 e alíquota de 5%, o método retornará: 1200 * 5 / 100, cujo valor do imposto fica R$ 60,00.</p>
            
            <h2>Utilização de interfaces</h2>
            <p>Interfaces podem ser utilizadas para definir comportamentos que podem ser aplicados a várias classes diferentes, tornando assim o código mais modular e fácil de manter.</p>
            <p>Por exemplo, suponha que temos um sistema de vendas que precisa calcular o imposto de diferentes tipos de produtos. Podemos criar a interface Tributavel, para definir o comportamento de calcular imposto, e criar várias classes diferentes que implementam essa interface para calcular o imposto de diferentes produtos. Por exemplo:</p>

            <pre>
                public class CalculadoraImposto {

                    private double totalImposto = 0;

                    public void calcularImposto(Tributavel item) {
                        this.totalImposto += item.getValorImposto();
                    }

                    public double getTotalImposto() {
                    return this.totalImposto;
                    }

                }
            </pre>

            <p>Nesse exemplo, estamos criando uma classe chamada CalculadoraImposto, que tem um atributo privado chamado totalImposto, que armazena o valor total dos impostos. </p>
            <p>Repare que o método calcularImposto recebe um parâmetro do tipo Tributavel. Ao declarar uma variável com o tipo de uma interface, como é feito nesse método, podemos atribuir a essa variável qualquer objeto que implemente essa interface, ou seja, tanto um objeto do tipo Servico quanto Produto. Para ambos os casos, a CalculadoraImposto irá chamar o método implementado na classe específica. Ou seja, para um produto, irá chamar o método getTotalImposto implementado na classe Produto. E para um serviço, irá chamar o método getTotalImposto implementado na classe Servico. </p>
            <p>Isso é muito útil quando queremos tratar vários objetos de classes diferentes de forma semelhante, permitindo que diferentes classes possam ser tratadas de maneira padronizada, facilitando a manutenção e extensão do código. Esse é mais um exemplo de aplicação do polimorfismo em Java, mas agora com a utilização de interfaces.</p>
        </section>
        
        <section>

            <h1 class="titulo">Declarando Variáveis com var</h1>
            <p>A partir da versão 10 do Java, foi adicionada uma nova funcionalidade para a declaração de variáveis chamada var. Essa nova palavra-chave permite que o compilador infira automaticamente o tipo da variável com base no valor atribuído a ela. Isso pode tornar o código mais limpo e legível, além de reduzir a digitação de código redundante.</p>

            <h3>Sintaxe básica</h3>
            <p>A sintaxe básica para declarar uma variável com var é a seguinte:</p>

            <p><strong>var nomeDaVariavel = valorInicial;</strong></p>

            <p>Onde nomeDaVariavel é o nome que você quer dar à variável e valorInicial é o valor que você quer atribuir a ela. O tipo da variável será inferido automaticamente pelo compilador com base no valor atribuído.</p>

            <p>Exemplo:</p>

            <p><strong>var numero = 10;</strong></p>

            <p>Nesse exemplo, a variável numero será inferida como sendo do tipo int, já que o valor atribuído é um número inteiro.</p>

            <h3>Limitações</h3>
            <p>A declaração de variáveis com var possui algumas limitações:</p>

            <p>O tipo da variável deve ser inferido automaticamente pelo compilador. Isso significa que não é possível utilizar var em variáveis cujo tipo não possa ser inferido automaticamente.</p>

            <p>Não é possível usar var em variáveis sem valor inicial. É necessário atribuir um valor à variável na mesma linha em que ela é declarada.</p>
        </section>
        <section>
            <h1 class="titulo">Array</h1>
            <p>Em Java, arrays são estruturas de dados que permitem armazenar uma coleção de elementos do mesmo tipo. Eles são muito utilizados para manipulação de dados em projetos de programação.</p>

            <p>Para declarar um array em Java, é preciso definir seu tipo e tamanho. Por exemplo, para criar um array de inteiros com tamanho 5, podemos escrever o seguinte código:</p>

            <p><strong>int[] numeros = new int[5];</strong></p>

            <p>Aqui, estamos declarando um array chamado "numeros" do tipo "int" e com tamanho 5. É importante lembrar que o índice dos elementos de um array começa em 0 e vai até o tamanho do array menos 1.</p>

            <p>Após declarar um array, podemos inicializá-lo com valores. Por exemplo, podemos preencher o array "numeros" com os números de 1 a 5 da seguinte forma:</p>

            <pre>

                for (int i = 0; i < numeros.length; i++) {
                    numeros[i] = i + 1;
                }
                
            </pre>

            <p>Aqui, estamos percorrendo o array "numeros" utilizando um loop for e preenchendo cada posição com seu respectivo índice mais 1.</p>

            <p>Também é possível criar arrays de objetos e não apenas de tipos primitivos. Por exemplo:</p>

            <pre>

                Filme[] filmes = new Filme[2];
                
                Filme filme1 = new Filme("Avatar", 2009);
                Filme filme2 = new Filme("Dogville", 2003);
                
                filmes[0] = filme1;
                filmes[1] = filme2;
                
            </pre>
            <p>Embora os arrays sejam úteis, eles possuem algumas limitações que podem causar problemas em projetos. Alguns desses problemas incluem:</p>

            <p>Tamanho fixo: o tamanho de um array é fixo e não pode ser alterado após a sua criação. Isso pode ser problemático em situações em que o tamanho dos dados a serem armazenados é desconhecido ou variável.</p>

            <p>Ausência de métodos: arrays não possuem métodos que permitam a inserção, remoção ou pesquisa de elementos de forma eficiente. Isso pode levar a soluções de código complicadas e ineficientes para tarefas simples.</p>

            <p>Justamente por conta desses problemas e dificuldades é que não devemos utilizar arrays para representar uma coleção de elementos, mas sim alguma classe do Java, como a <strong>ArrayList</strong>, que encapsula e abstrai um array, facilitando a sua utilização via métodos e deixando o código do projeto mais simples de entender e evoluir.</p>
        </section>
        <section>
            
            <h1 class="titulo">ArrayList</h1>
            <h2>Criando ArrayList</h2>
            <p class="codigo"><span class="preAmarelo">ArrayList&lt;Filme&gt;</span> listaDeFilmes = new <span class="preAmarelo">ArrayList&lt;&gt;()</span>;</p>
            <h2>Adicionando</h2>
            <p class="codigo">listaDeFilmes.add(filmeDoPaulo);</p>
            <h2>Tamando da Lista</h2>
            <p class="codigo">listaDeFilmes.size();</p>
            <h2>Acessando Objeto</h2>
            <p class="codigo">listaDeFilmes.get(0).getNome();</p>

            <h2>Arrays no Java</h2>
            <p>Em Java, arrays são estruturas de dados que permitem armazenar uma coleção de elementos do mesmo tipo. Eles são muito utilizados para manipulação de dados em projetos de programação.</p>
            <p>Para declarar um array em Java, é preciso definir seu tipo e tamanho. Por exemplo, para criar um array de inteiros com tamanho 5, podemos escrever o seguinte código:</p>
            <p class="codigo">int[] numeros = new int[5];</p>
            <p>Aqui, estamos declarando um array chamado "numeros" do tipo "int" e com tamanho 5. É importante lembrar que o índice dos elementos de um array começa em 0 e vai até o tamanho do array menos 1.</p>
            <p>Após declarar um array, podemos inicializá-lo com valores. Por exemplo, podemos preencher o array "numeros" com os números de 1 a 5 da seguinte forma:</p>
            <pre>
                    for (int i = 0; i < numeros.length; i++) {
                        numeros[i] = i + 1;
                    }
            </pre>
            <p>Aqui, estamos percorrendo o array "numeros" utilizando um loop for e preenchendo cada posição com seu respectivo índice mais 1.</p>
            <p>Também é possível criar arrays de objetos e não apenas de tipos primitivos. Por exemplo:</p>
            <pre>
                Filme[] filmes = new Filme[2];

                Filme filme1 = new Filme("Avatar", 2009);
                Filme filme2 = new Filme("Dogville", 2003);

                filmes[0] = filme1;
                filmes[1] = filme2;
            </pre>
            <p>Embora os arrays sejam úteis, eles possuem algumas limitações que podem causar problemas em projetos. Alguns desses problemas incluem:</p>
            <p>Tamanho fixo: o tamanho de um array é fixo e não pode ser alterado após a sua criação. Isso pode ser problemático em situações em que o tamanho dos dados a serem armazenados é desconhecido ou variável.</p>
            <p>Ausência de métodos: arrays não possuem métodos que permitam a inserção, remoção ou pesquisa de elementos de forma eficiente. Isso pode levar a soluções de código complicadas e ineficientes para tarefas simples.</p>
            <p>Justamente por conta desses problemas e dificuldades é que não devemos utilizar arrays para representar uma coleção de elementos, mas sim alguma classe do Java, como a ArrayList, que encapsula e abstrai um array, facilitando a sua utilização via métodos e deixando o código do projeto mais simples de entender e evoluir.</p>

        </section>
        <section>
            <h1 class="titulo">Construtor</h1>
            <p>Em Java, um construtor é um método especial usado para criar e inicializar um objeto recém-criado. Quando uma classe é definida, ela pode ter um ou mais construtores, sendo que se nenhum construtor for definido explicitamente, o Java criará um construtor default (padrão) automaticamente.</p>
            <p>Um construtor default é um construtor que não possui parâmetros e não executa nenhuma instrução. Ele é chamado sempre que um objeto da classe é criado sem argumentos. Por exemplo:</p>
            <pre>
                public class Pessoa {

                    private String nome;
                    private String email;

                    public Pessoa() {
                    }

                    //metodos getters/setters
                }
            </pre>
            <p>No exemplo de código anterior, a classe Pessoa possui um construtor default, que será exatamente o mesmo construtor que o Java criará automaticamente, caso nenhum construtor tivesse sido definido na classe.</p>
            <p>Se uma classe define explicitamente um ou mais construtores, mas não define um construtor sem parâmetros, então não há construtor default. Nesse caso, se um objeto é criado sem argumentos, um erro de compilação será gerado.</p>
            <p>É importante ressaltar que mesmo que um construtor default possa ser útil em alguns casos, é sempre recomendável definir explicitamente os construtores da classe, especialmente se a classe tiver atributos que precisam ser inicializados com valores específicos ou obrigatórios. Isso também torna o código mais claro e fácil de entender.</p>
        </section>
        <section>
            <h1 class="titulo">Formas de Percorrer Listas</h1>
            <p>A forma mais comum de percorrer uma lista no Java é utilizando o laço foreach tradicional, também conhecido como for-each. Esse laço permite que se percorra todos os elementos de uma lista, sem a necessidade de se preocupar com índices ou o tamanho dela, tornando o código mais simples e legível. Por exemplo, suponha que tenhamos uma lista de nomes de pessoas e que desejamos imprimi-los na tela:</p>
            <pre>
                ArrayList&lt;String&gt; nomes = new ArrayList<>();
                nomes.add("Jacqueline");
                nomes.add("Paulo");
                nomes.add("Suellen");
                nomes.add("Emily");

                for (String nome : nomes) {
                    System.out.println(nome);
                }                
            </pre>
            <p>Esse loop for percorre todos os elementos da lista, atribuindo cada um deles à variável nome, que é usada para imprimir o valor na tela. Esse tipo de loop é muito útil em situações onde não precisamos realizar nenhuma operação complexa sobre os elementos da lista.</p>
            <p>No entanto, a partir do Java 8, foi adicionado na interface List, a qual a classe ArrayList implementa, um novo método chamado forEach, que possibilita a iteração sobre os elementos da lista de forma mais concisa e elegante. Por exemplo, o exemplo anterior pode ser reescrito utilizando o método forEach da seguinte forma:</p>
            <p class="codigo">nomes.forEach(nome -> System.out.println(nome));</p>
            <p>Nesse caso, o método forEach é chamado sobre a lista nomes e recebe como parâmetro uma expressão lambda que realiza a impressão do valor na tela. A expressão lambda nome -> System.out.println(nome) é uma forma compacta de definir uma função que recebe um parâmetro nome e realiza a operação de impressão.</p>
            <p>É possível simplificar ainda mais o exemplo de código anterior, utilizando o recurso conhecido como Method Reference, que nada mais é do que uma forma reduzida de uma expressão lambda:</p>
            <p class="codigo">nomes.forEach(System.out::println);</p>
            <p>No código anterior, o símbolo :: é a sintaxe do Method Reference, que no exemplo mostrado faz uma referência para o método println.</p>
        </section>
        <section>
            <h1 class="titulo">Variáveis e referências</h1>
            <p>Referências são ponteiros para objetos em memória, ou seja, elas apontam para um objeto e permitem que você trabalhe com ele. No Java, toda variável de objeto é na verdade uma referência a esse objeto que foi alocado na memória. </p>
            <p>Quando você instancia um objeto, está, na realidade, criando um novo bloco de memória que armazena as informações desse objeto. A maneira de chegar a esse bloco de memória, para armazenar e ler informações dele, ocorre por meio de uma referência, que é representada por uma variável. Por exemplo:</p>
            <p class="codigo">Filme filme1 = new Filme("Avatar", 2009);</p>
            <p>No exemplo de código anterior, criamos um novo objeto da classe Filme e armazenamos uma referência a ele na variável filme1.</p>
            <p>É importante lembrar que as referências a objetos em Java não são o próprio objeto em si, pois elas apenas apontam para o objeto. Quando você passa uma referência a um método ou atribui uma referência a outra variável, está apenas copiando o valor da referência e não do objeto em si. Por exemplo:</p>
            <pre>
                Filme filme1 = new Filme("Avatar", 2009);
                Filme filme2 = new Filme("The Matrix", 1999);
                Filme filme3 = filme1;
            </pre>
            <p>No exemplo de código anterior, foram criados apenas dois objetos em memória. A variável filme3 é apenas uma referência que aponta para o mesmo objeto sendo referenciado pela variável filme1.</p>
            <p>Uma questão importante relacionada com referências a objetos em Java é a questão da igualdade e identidade de objetos. Quando você compara duas referências de objeto usando o operador de igualdade ==, está comparando as referências em si, não os objetos que elas apontam. Por exemplo:</p>
            <pre>
                Filme filme1 = new Filme("Avatar", 2009);
                Filme filme2 = new Filme("Avatar", 2009);

                if (filme1 == filme2) {
                    System.out.println("Iguais");
                } else {
                    System.out.println("Diferentes");
                }
            </pre>
            <p>No exemplo de código anterior, a saída no console será: "Diferentes". Embora os dois objetos tenham as mesmas informações na memória, a comparação com == verifica se as referências são iguais, ou seja, se apontam para o mesmo objeto na memória.</p>
        </section>
        <section>
            <h1 class="titulo">Utilizando Collections.sort para ordenar listas</h1>
            <pre>
                ArrayList<String> buscaPorArtista = new ArrayList<>();
                buscaPorArtista.add("Adam Sandler");
                buscaPorArtista.add("Paulo");
                buscaPorArtista.add("Jacqueline");
                System.out.println(buscaPorArtista);

                Collections.sort(buscaPorArtista);
                System.out.println("Depois da ordenação");
                System.out.println(buscaPorArtista);
            </pre>
            <p>Para utilizar o Collections.sort a classe precisa inplementar a interface <strong>Comparable</strong> no caso das variáveis primitivas e o objeto String as classes já implementam esta interface, porém as classes que não tiverem esta interface, precisamos implementa-la.</p>
            <h2>Implementando a interface Comparable</h2>
            <p>Primeiro instanciamos a interface Comparable na classe</p>
            <p class="codigo">public class Titulo implements Comparable&lt;Titulo&gt;{...}</p>
            <p>Depois precisamos criar o método da interface que é o compareTo</p>
            <pre>
                @Override
                public int compareTo(Titulo outroTitulo) {
                    return this.getNome().compareTo(outroTitulo.getNome());
                }
            </pre>
            <p>Agora podemos utilizar o Collections.sort em nossa lista de objetos</p>
            <p class="codigo">Collections.sort(lista);</p>
            <p>Se quisermos ordenar utilizando outros métodos de comparação:</p>
            <p class="codigo">lista.sort(Comparator.comparing(Titulo::getAnoDeLancamento));</p>
            
        </section>
        <section>
            <h1 class="titulo">Outras classes de listas no Java</h1>
            <p>O Java oferece diferentes classes para representar uma lista de objetos. Essas classes são úteis em diferentes cenários, dependendo das necessidades de cada aplicação.</p>
            <p>As classes mais comuns para representar uma lista no Java são:</p>
            <h2>ArrayList</h2>
            <p>A principal característica do ArrayList é que ele é baseado em um array dinâmico. Ele armazena os elementos em uma matriz interna e, conforme novos elementos são adicionados, o tamanho da matriz é automaticamente ajustado para acomodar o novo elemento. Da mesma forma, quando um elemento é removido, o tamanho do array é ajustado para evitar o desperdício de espaço. O ArrayList é amplamente utilizado devido à sua facilidade de uso e eficiência em termos de desempenho.</p>
            <h2>LinkedList</h2>
            <p>A classe LinkedList fornece uma lista encadeada de elementos. Diferentemente do ArrayList, que é baseado em um array, o LinkedList é baseado em uma lista encadeada, o que significa que cada elemento da lista é um objeto que contém uma referência para o próximo elemento. Isso permite que os elementos sejam adicionados e removidos de maneira eficiente em qualquer posição da lista, mas pode tornar a pesquisa de um elemento específico menos eficiente./p>
            <p>O LinkedList é uma boa escolha quando a inserção e remoção de elementos em qualquer posição da lista é frequente e quando não é necessário acessar os elementos de forma aleatória.</p>
            <h2>Vector</h2>
            <p>A classe Vector é semelhante ao ArrayList, mas é sincronizada, o que significa que é segura para uso em threads concorrentes. No entanto, a sincronização adiciona uma sobrecarga de desempenho, então o Vector pode ser mais lento que o ArrayList em algumas situações.</p>
            <h2>Stack</h2>
            <p>A classe Stack implementa uma pilha, que é uma coleção ordenada de elementos onde a inserção e remoção de elementos ocorrem sempre no mesmo extremo da lista. Os elementos são adicionados e removidos em uma ordem conhecida como "last-in, first-out" (LIFO), ou seja, o último elemento adicionado é o primeiro a ser removido. A classe Stack é usada com frequência em algoritmos de processamento de texto, bem como em outras situações em que a LIFO é a maneira natural de organizar os dados.</p>
            <p>Cada uma dessas classes tem seus próprios pontos fortes e fracos, e a escolha de qual usar dependerá das necessidades específicas da aplicação. Para um melhor entendimento sobre estruturas de dados, recomendamos a leitura dos seguintes artigos:</p>
        </section>
        <section>
            <h1 class="titulo">Map e HashMap</h1>
            <p>Uma das características mais importantes do Java é sua vasta biblioteca padrão, que oferece muitas classes e interfaces úteis para os desenvolvedores. Entre elas, estão o Map e o HashMap, que são ferramentas essenciais para associação de chaves e valores em muitas aplicações Java.</p>
            <h2>Map</h2>
            <p>O Map é uma interface que permite que os desenvolvedores associem chaves a valores. É uma estrutura de dados útil para muitas aplicações Java, especialmente aquelas que envolvem a manipulação de grandes quantidades de dados, portanto, é comum usá-lo para realizar buscas, atualização e recuperação de elementos por chaves</p>
            <p>Ele é implementado por diversas classes, sendo a mais comum delas o HashMap.</p>
            <h2>HashMap</h2>
            <p>O HashMap é uma classe que implementa a interface Map usando uma tabela hash para armazenar os pares chave-valor. Ele é conhecido por sua eficiência em termos de tempo de execução. Essa classe tem uma complexidade de tempo O(1) - constante - para inserção, recuperação e remoção de elementos. Isso significa que o desempenho do HashMap não depende do tamanho da coleção de dados! </p>
            <p>No entanto, é importante lembrar que o HashMap não mantém a ordem de inserção dos elementos e não garante a ordem dos elementos na saída. Isso ocorre porque a ordem dos elementos depende da função de hash usada para mapear as chaves para índices na tabela hash. Além disso, o desempenho do HashMap pode ser afetado se houver muitas colisões de hash entre as chaves.</p>
            <p>Por exemplo:</p>
            <pre>
                import java.util.HashMap;
                import java.util.Map;

                public class ExemploHashMap {

                    public static void main(String[] args) {
                        //Criando um objeto da classe HashMap que implementa a interface Map
                        Map<String, Integer> usandoHashMap = new HashMap<>();

                        // Adicionando pares chave-valor
                        usandoHashMap.put("Gatos", 1);
                        usandoHashMap.put("Cachorros", 2);
                        usandoHashMap.put("Roedores", 3);

                        // Acessando um valor através de uma chave
                        int valor = usandoHashMap.get("Cachorros");
                        System.out.println("Valor da chave Cachorros: " + valor);

                        // Removendo um par chave-valor
                        usandoHashMap.remove("Gatos");

                        // Iterando sobre as chaves
                        for (String chave : usandoHashMap.keySet()) {
                            System.out.println("Chave: " + chave);
                            System.out.println("Valor: " + usandoHashMap.get(chave));
                        }
                    }
                }
            </pre>
            <p>O resultado será:</p>
            <pre>
                Valor da chave Cachorros: 2
                Chave: Cachorros
                Valor: 2
                Chave: Roedores
                Valor: 3
            </pre>
        </section>
        <section>
            <h1 class="titulo">HttpRequest</h1>
            <pre>
                HttpRequest <span class="preAmarelo">request</span> = HttpRequest.newBuilder()
                    .uri(URI.create("https://viacep.com.br/ws/37490000/json/"))
                    .build();

                HttpResponse&lt;String&gt; <span class="pre1">response</span> = HttpClient
                        .newHttpClient()
                        .send(<span class="preAmarelo">request</span>, HttpResponse.BodyHandlers.ofString());

                String resposta = <span class="pre1">response</span>.body();
            </pre>
        </section>
                <section>
            <h1 class="titulo">Adicionando Biblioteca manualmente</h1>
            <section>
                <p>Primeiro acessar o site MVN Repository <a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
                <p>Pesquisar Gson</p>
                <p>Acessar a biblioteca Gson</p>
                <p>Selecionar uma versão sem vulnerabilidade</p>
                <p>Clicar em Jar que esta em files, para baixar o arquivo jar</p>
                <p>Agora no IntelliJ</p>
                <figure>
                    <img src="IMG/java/1.png" alt="Project Structure">
                    <figcaption>clicar em file e depois em Project Structure</figcaption>
                </figure>
                <figure>
                    <img src="IMG/java/2.png" alt="Dependencies">
                    <figcaption>Ir em Project Settings > Modules > Dependencies</figcaption>
                </figure>
                <figure>
                    <img src="IMG/java/3.png" alt="Adicionando Arquivo">
                    <figcaption>Clicar em + para adicionar o arquivo e depois em ok</figcaption>
                </figure>
                <p>Agora basta colocar:</p>
                <p class="codigo">Gson gson = new Gson();</p>
            </section>
        </section>
        <section>
            <h1 class="titulo">Classe Record</h1>
            <p>Utilizado para Tradução de campos, quando precisamos receber dados de uma api e traduzir para nossa classe</p>
            <figure>
                <img src="IMG/java/4.png" alt="Classe do tipo Record">
                <figcaption>
                    <p>Clicar em cima da pasta modelos com o botão direito</p>
                    <p>New Java Class</p>
                    <p>Escolhe o nome e depois seleciona <strong>Record</strong></p>
                </figcaption>
            </figure>
            <p>Agora apenas precisamos definir os atributos que desejamos, de acordo com os atributos que vem da api</p>
            <p class="codigo">public <span class="pre1">record</span> TituloOmdb(String title, String year, String runtime) {}</p>
            <pre>
                String json = response.body();
                System.out.println(json);

                Gson gson = new Gson();

                TituloOmdb meuTituloOmdb = gson.fromJson(json, TituloOmdb.class);
                System.out.println(meuTituloOmdb);
            </pre>
            <p>A saída será:</p>
            <pre>
                {"Title":"Matrix","Year":"1993","Rated":"N/A","Released":"01 Mar 1993","Runtime":"60 min","Genre":"Action, Drama, Fantasy","Director":"N/A","Writer":"Grenville Case","Actors":"Nick Mancuso, Phillip Jarrett, Carrie-Anne Moss","Plot":"Hitman Steven Matrix is shot, experiences afterlife, gets second chance by helping others. Wakes up, meets guides assigning cases where he aids people using unorthodox methods from past profession.","Language":"English","Country":"Canada","Awards":"1 win total","Poster":"https://m.media-amazon.com/images/M/MV5BM2JiZjU1NmQtNjg1Ni00NjA3LTk2MjMtNjYxMTgxODY0NjRhXkEyXkFqcGc@._V1_SX300.jpg","Ratings":[{"Source":"Internet Movie Database","Value":"7.2/10"}],"Metascore":"N/A","imdbRating":"7.2","imdbVotes":"225","imdbID":"tt0106062","Type":"series","totalSeasons":"N/A","Response":"True"}
                TituloOmdb[title=null, year=null, runtime=null]
            </pre>
            <p>title year e runtime aparecem como null, pois na api as propriedades estão em maiúsculo, porém o padrão para variáveis é em minúsculo.</p>
            <p>Na biblioteca Gson já temos uma opção para contornar este problema.</p>
            <p>Pesquisamos Field Name Policy na documentação e acharemos um código para resolvermos o problema:</p>
            <p class="codigo">Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();</p>
            <h2>Agora Utilizando a classe Record para podermos usar a nossa classe</h2>
            <p class="codigo"><span class="pre1">Titulo</span> meuTitulo = new <span class="pre1">Titulo</span>(meuTituloOmdb);</p>
            <p>Agora precisamos criar um construtor na classe Titulo que recebe TituloOmdb</p>
            <pre>
                public Titulo(TituloOmdb meuTituloOmdb) {
                    this.nome = meuTituloOmdb.title();
                    this.anoDeLancamento = Integer.valueOf(meuTituloOmdb.year());
                    this.duracaoEmMinutos = Integer.valueOf(meuTituloOmdb.runtime().split(" ")[0]);
                }
            </pre>
            <p>Como a resposta json vem em String, precisamos converter para os tipos da nossa classe.</p>
            <p>No caso do nome, não foi necessário, porém no caso do anoDeLancamento e duracaoEmMinutos já foi necessário.</p>

        </section>
        <section>
            <h1 class="titulo"> Para saber mais: Java Record</h1>
            <p>Lançado oficialmente no Java 16, mas disponível desde o Java 14 de maneira experimental, o Record é um recurso que permite representar uma classe imutável, contendo apenas atributos, construtor e métodos de leitura, de uma maneira muito simples e enxuta.</p>
            <p>Esse recurso se encaixa perfeitamente quando precisamos criar um objeto apenas para representar dados, sem nenhum tipo de comportamento.</p>
            <p>Para se criar uma classe imutável, sem a utilização do Record, era necessário escrever muito código. Vejamos um exemplo de uma classe que representa um telefone:</p>
            <pre>
                public final class Telefone {

                    private final String ddd;
                    private final String numero;

                    public Telefone(String ddd, String numero) {
                        this.ddd = ddd;
                        this.numero = numero;
                    }

                    @Override
                    public int hashCode() {
                        return Objects.hash(ddd, numero);
                    }

                    @Override
                    public boolean equals(Object obj) {
                        if (this == obj) {
                            return true;
                        } else if (!(obj instanceof Telefone)) {
                            return false;
                        } else {
                            Telefone other = (Telefone) obj;
                            return Objects.equals(ddd, other.ddd)
                            && Objects.equals(numero, other.numero);
                        }
                    }

                    public String getDdd() {
                        return this.ddd;
                    }

                    public String getNumero() {
                        return this.numero;
                    }
                }
            </pre>
            <p>Agora com o Record, todo esse código pode ser resumido com uma única linha:</p>
            <p class="codigo">public record Telefone(String ddd, String numero){}</p>
            <p>Por baixo dos panos, o Java vai transformar esse Record em uma classe imutável, muito similar ao código exibido anteriormente.</p>
        </section>
        <section>
            <h1 class="titulo">Bibliotecas e Frameworks</h1>
            <p>Bibliotecas e frameworks em Java, e também em outras linguagens de programação, são ferramentas essenciais para quem trabalha com programação, pois ajudam a reduzir a quantidade de trabalho necessária para construir aplicações, uma vez que fornecem funcionalidades prontas para uso, permitindo que as pessoas desenvolvedoras foquem na lógica de negócios dos projetos, ao invés de se preocuparem com problemas técnicos que são comuns e já possuem soluções prontas para uso.</p>
            <p>Em Java, bibliotecas são coleções de classes e interfaces que oferecem uma série de recursos e funcionalidades prontas para uso. Geralmente elas são distribuídas como arquivos JAR (Java Archive), que são pacotes de arquivos Java que contém classes e outros recursos, como imagens e arquivos de configuração. As bibliotecas podem ser importadas em projetos Java e usadas diretamente em código para implementar funcionalidades específicas, como manipulação de arquivos, conexão com bancos de dados, criptografia, etc.</p>
            <p>Frameworks, por outro lado, são estruturas de software que fornecem uma arquitetura básica para o desenvolvimento de aplicações. Eles incluem bibliotecas, padrões e práticas recomendadas para orientar o processo de desenvolvimento de aplicações. Um framework pode ser considerado como uma "fábrica padronizada de aplicações", que fornece os componentes necessários para criar uma aplicação, bem como um conjunto de regras e diretrizes para guiá-lo no processo.</p>
            <p>Existem muitos frameworks populares em Java, cada um com suas próprias características e objetivos. Alguns exemplos incluem o Spring Framework, que é um framework que facilita a criação de aplicações Web e APIs Rest complexas em Java; o Hibernate, que é um framework de mapeamento objeto-relacional e simplifica muito o processo de integração de uma aplicação Java com um banco de dados relacional.</p>
        </section>
        <section>
            <h1 class="titulo">Para saber mais: imutabilidade</h1>
            <p>A imutabilidade, citada anteriormente ao falarmos sobre record, é um conceito importante em Java, que se refere à capacidade de um objeto não poder ser alterado depois de criado. Existem algumas classes que são imutáveis por padrão, como por exemplo, as classes String, Integer, Boolean, entre outras. Isso significa que, uma vez criado um objeto dessas classes, não é possível modificar o seu estado.</p>
            <p>Vamos exemplificar. Dado o record abaixo:</p>
            <p class="codigo">public record Estudante(String nome, int idade) {}</p>
            <p>Uma vez criado um objeto Estudante, seus valores não podem ser modificados:</p>
            <p class="codigo">Estudante estudante1 = new Estudante(“Alice”, 19);</p>
            <p>Observe que após essa criação, eu não consigo setar outro nome ou idade para o objeto estudante1.</p>
            <pre>
                <span class="pre1">estudante1.</span>setNome(“Maria”); //Essa possibilidade não existe
                <span class="pre1">estudante1.</span>nome = “Maria”; //Essa possibilidade não existe
            </pre>
            <p>Qualquer uma das tentativas acima, vai apresentar erro de compilação, pois não é possível atribuir nenhum outro nome a variável estudante1.</p>
            <p>Com relação ao record, fica bem claro, certo? Mas e a String, por exemplo? Eu consigo fazer os passos abaixo no código:</p>
            <pre>
                String nome = “Maria”;
                nome = “Alice”;
            </pre>
            <p>Se a String é imutável, o certo era eu não conseguir atribuir o conteúdo “Alice” à variável nome, correto? </p>
            <p>No caso da String e de outras classes imutáveis que citei acima, a variável nome contém uma referência ao objeto da classe String que contém o valor "Maria".</p>
            <p>No entanto, quando você tenta alterar o valor da string, o que realmente acontece é que um novo objeto da classe String é criado com o novo valor e a variável é atualizada para armazenar uma referência ao novo objeto.</p>
            <p>Por isso, podemos dizer que a classe String é imutável, porque uma vez que um objeto da classe String é criado, ele não pode ser alterado. No entanto, as variáveis que armazenam referências a objetos da classe String podem ser atualizadas para referenciar novos objetos, que são criados a partir do conteúdo do objeto original.</p>
            <p>A imutabilidade é importante por várias razões, entre elas:</p>
            <ul class="ul">
                <li><strong>Concorrência:</strong> objetos imutáveis são seguros para uso em ambientes concorrentes, já que não há necessidade de sincronização.</li>
                <li><strong>Segurança:</strong> objetos imutáveis são seguros contra alterações acidentais ou mal-intencionadas.</li>
                <li><strong>Desempenho:</strong> objetos imutáveis podem ser armazenados em cache e reutilizados, o que pode melhorar o desempenho.</li>
            </ul>
        </section>
        <section>
            <h1 class="titulo"> Para saber mais: o bloco finally</h1>
            <p>Aprendemos que quando ocorre uma exceção, o Java permite tratar o erro usando a declaração try-catch. Entretanto, existe ainda o bloco finally, que é opcional, mas pode ser útil em certas situações.</p>
            <p>O finally é usado para executar um bloco de código independentemente de ocorrer uma exceção ou não, ou seja, ele sempre é executado. Isso pode ser útil quando precisamos executar um código tanto no try, caso não ocorra uma exceção, quanto no catch, caso uma exceção seja lançada. Por exemplo, suponha que você tenha o seguinte código:</p>
            <pre>
                try {
                    metodoQuePodeLancarExcecao();
                    System.out.println("Executou");

                    System.out.println("Finalizou!");
                    } catch (Exception e) {
                    System.out.println("Deu erro!");

                    System.out.println("Finalizou!");
                }
            </pre>
            <p>Perceba no código anterior que a instrução System.out.println("Finalizou!"); deve ser sempre executada, independente de ter acontecido ou exception ou não. Mas o problema é que ela acabou tendo de ser duplicada tanto no try quanto no catch. O bloco finally nos ajuda justamente a evitar essa duplicação de código:</p>
            <pre>
                try {
                    metodoQuePodeLancarExcecao();
                    System.out.println("Executou");
                    } catch (Exception e) {
                    System.out.println("Deu erro!");
                    } finally {
                    System.out.println("Finalizou!");
                }
            </pre>
            <p>Repare que agora a instrução aparece apenas uma vez, dentro do bloco finally, evitando com isso uma duplicação de código desnecessária. </p>
            <p>O finally é muito utilizado em situações onde é necessário limpar recursos, fechar conexões de banco de dados ou fechar arquivos que foram abertos no bloco try.</p>

        </section>
        <section>
            <h1 class="titulo">Para saber mais: hierarquia de exceptions no Java</h1>
            <p>No Java, as exceções são organizadas em uma hierarquia de classes. Todas as exceções são subclasses da classe Throwable, sendo que ela possui duas subclasses principais: Exception e Error.</p>
            <figure>
                <img src="IMG/java/5.webp" alt="hierarquia de exceptions no Java">
            </figure>
            <p>As exceções que herdam da classe Exception são chamadas de exceções verificadas (checked exceptions). Isso significa que essas exceções devem ser tratadas explicitamente em um bloco try-catch ou declaradas em uma cláusula throws na assinatura do método. Um exemplo é a classe de exceção IOException, que indica algum problema relacionado com leitura/escrita de dados.</p>
            <p>As exceções que herdam da classe Error representam erros irrecuperáveis pelo sistema, como falta de memória ou falhas internas. Um exemplo é a classe de exceção OutOfMemoryError, que indica que o Java não conseguiu memória suficiente do sistema operacional para executar corretamente a aplicação.</p>
            <p>Além disso, existe ainda a classe de exceção RuntimeException, que é uma subclasse direta de Exception, e as classes que herdam dela são chamadas de exceções não verificadas (unchecked exception). As exceções não verificadas indicam erros lógicos no código, como a NullPointerException, que indica o acesso a algum atributo ou método de um objeto que é nulo, ou seja, que não foi instanciado ou foi atributo ao valor null.</p>
            <p>Ao lidar com exceções em um bloco try-catch, é importante considerar a hierarquia de exceções. É possível capturar exceções de uma classe mãe em um bloco catch que captura exceções de uma classe filha. No entanto, o inverso não é possível. Isso significa que, se um bloco catch captura exceções de uma classe filha, ele não será capaz de capturar exceções de uma classe mãe.</p>
            <p>Exemplo: Imagine uma exceção IOException (classe mãe) e uma exceção FileNotFoundException (classe filha). Um bloco catch que captura IOException irá capturar tanto IOException quanto FileNotFoundException, pois FileNotFoundException é um tipo específico de IOException. No entanto, um bloco catch que captura FileNotFoundException não irá capturar IOException.</p>
            <p>É importante lembrar que, ao usar a hierarquia de classes para tratar exceções, devemos priorizar o tratamento específico de exceções de classes filhas. Em seguida, podemos incluir um bloco catch mais genérico para tratar exceções de classes mães.</p>
        </section>
        <section>
            <h1 class="titulo"> Para saber mais: Multi-catch</h1>
            <p>A partir do Java 7, a linguagem introduziu uma nova funcionalidade chamada "multi-catch", que permite capturar várias exceções em um único bloco catch. Essa funcionalidade pode tornar o código mais conciso e legível, reduzindo a repetição de código.</p>
            <p>O uso de multi-catch é muito simples. Em vez de ter vários blocos catch para lidar com diferentes exceções, você pode agrupá-las em um único bloco usando o caractere | para separar as exceções. Por exemplo, suponha que você tenha escrito o seguinte código:</p>
            <pre>
                try {
                    metodoQuePodeLancarExcecao();
                } catch (NumberFormatException e) {
                    System.out.println("tratando erro...");
                } catch (IllegalArgumentException e) {
                    System.out.println("tratando erro...");
                }
            </pre>
            <p>Como o tratamento do erro é o mesmo para ambas as exceções, o código anterior poderia ter sido escrito utilizando o multi-catch:</p>
            <pre>
                try {
                    metodoQuePodeLancarExcecao();
                } catch (NullPointerException | IllegalArgumentException e) {
                    System.out.println("tratando erro...");
                }
            </pre>
            <p>No exemplo anterior, estamos lidando com duas exceções diferentes: NullPointerException e IllegalArgumentException. Se qualquer uma dessas exceções for lançada dentro do bloco try, o mesmo bloco catch será executado.</p>
            <p>Uma observação importante de lembrar, é que o uso de multi-catch só é permitido para exceções que não estão relacionadas por uma hierarquia de herança. Se duas exceções compartilham uma hierarquia de herança, você deve lidar com elas em blocos catch separados.</p>
        </section>
        <section>
            <h1 class="titulo">Crianco Exceção Personalizada</h1>
            <p class="codigo">throw new ErroDeConvercaoDeAnoExeption("Não consegui converter o ano porque tem mais de 4 caracteres.");</p>
            <p>A IDE irá mostrar um erro, pois não temos a classe ErroDeConvercaoDeAnoExeption, então é só passar o mause em cima que já da a opção de criar a classe.</p>
            <p>Classe ErroDeConvercaoDeAnoExeption:</p>
            <pre>
                public class ErroDeConvercaoDeAnoExeption extends RuntimeException {
                    private String mensagem;
                    public ErroDeConvercaoDeAnoExeption(String mensagem) {
                        this.mensagem = mensagem;
                    }

                    @Override
                    public String getMessage() {
                        return this.mensagem;
                    }
                }
            </pre>
            <p>Dentro do construtor da classe Titulo colocamos um if:</p>
            <pre>
                public Titulo(TituloOmdb meuTituloOmdb) {
                    this.nome = meuTituloOmdb.title();

                    if(meuTituloOmdb.year().length() > 4){
                        throw new ErroDeConvercaoDeAnoExeption("Não consegui converter o ano porque tem mais de 4 caracteres.");
                    }
                    this.anoDeLancamento = Integer.valueOf(meuTituloOmdb.year());
                    this.duracaoEmMinutos = Integer.valueOf(meuTituloOmdb.runtime().split(" ")[0]);
                }
            </pre>
            <p>Nosso cath fica assim:</p>
            <pre>
                catch (ErroDeConvercaoDeAnoExeption e){
                    System.out.println(e.getMessage());
                }
            </pre>
        </section>
        <section>
            <h1 class="titulo">Para saber mais: o pacote java.io</h1>
            <p>O Java possui um pacote chamado java.io, que é um dos pacotes mais importantes da linguagem, pois fornece classes e interfaces para entrada e saída de dados em vários formatos, como arquivos, rede, teclado, dentre outros. Vamos conhecer as principais classes desse pacote.</p>
            <h2>A classe File</h2>
            <p>A classe File representa um arquivo ou diretório no sistema de arquivos do computador, permitindo que você crie, delete, liste e manipule arquivos e diretórios. Para criar um objeto File, você precisa passar o caminho do arquivo ou diretório como argumento para o construtor. Por exemplo:</p>
            <p class="codigo">File file = new File("C:\\meuArquivo.txt");</p>
            <p>No código anterior, foi criado um objeto File que aponta para o arquivo "meuArquivo.txt" localizado na raiz do disco C:.</p>
            <p>A classe File tem vários métodos úteis para interagir com arquivos e diretórios, como exists(), canRead(), canWrite(), isDirectory(), isFile(), mkdir() e delete().</p>
            <h2>As classes FileReader e FileWriter</h2>
            <p>As classes FileReader e FileWriter são usadas para ler e escrever dados em arquivos de texto, sendo que a classe FileReader lê os caracteres de um arquivo de texto, enquanto a classe FileWriter escreve os caracteres.</p>
            <p>Para usar a classe FileReader, você precisa criar um objeto passando um objeto File que deseja ler como argumento. Em seguida, você pode ler os dados do arquivo usando o método read() ou read(char[]). Por exemplo:</p>
            <pre>
                File file = new File("C:\\meuArquivo.txt");
                FileReader reader = new FileReader(file);

                int data = reader.read();
                while (data != -1) {
                    System.out.print((char) data);
                    data = reader.read();
                }
                reader.close();
            </pre>
            <p>No código anterior, é feita a leitura do conteúdo do arquivo "meuArquivo.txt" e seu conteúdo é impresso no console</p>
            <p>Já a classe FileWriter segue o mesmo processo, porém fazendo o caminho inverso, ou seja, escrevendo caracteres no arquivo. Por exemplo:</p>
            <pre>
                File file = new File("C:\\saida.txt");
                FileWriter writer = new FileWriter(file);
                writer.write("Olá, mundo!");
                writer.close();
            </pre>
            <p>No código anterior, é escrito uma mensagem no arquivo chamado "saida.txt".</p>
            <p>O pacote java.io também fornece outras classes úteis, como:</p>
            <ul>
                <li><strong>BufferedReader e BufferedWriter:</strong> são usadas para ler e gravar arquivos de texto de maneira eficiente, lendo e escrevendo uma linha por vez. Elas usam um buffer para armazenar os dados, o que torna a leitura e escrita mais rápida do que quando feita um caractere por vez;</li>
                <li><strong>FileInputStream e FileOutputStream: </strong>são usadas para ler e gravar dados binários em um arquivo. Eles são usados para ler e gravar dados em arquivos que não são de texto, como imagens e arquivos de áudio;</li>
                <li><strong>ObjectInputStream e ObjectOutputStream:</strong> são usadas para ler e gravar objetos em arquivos. Isso permite que você armazene objetos Java em arquivos para uso posterior ou para transferência entre diferentes aplicações.</li>
            </ul>
        </section>
        <section>
            <h1 class="titulo">Conversão de tipos</h1>
            <p>De double para int:</p>
            <pre>
                double valorDouble = 19.5; 
                int valorInt = (int) valorDouble;
            </pre>
            <p>Pontos de atenção:</p>
            <ul class="ul">
                <li>O casting não arredonda o número, ele simplesmente corta a parte decimal.</li>
                <li>Se precisar arredondar, pode-se usar <strong>Math.round(), Math.floor()</strong> (arredondamento para baixo) ou <strong>Math.ceil()</strong> (arredondamento para cima).</li>
            </ul>
        </section>
        <!-- Exemplo de Código -->
        <section>
            <h1 class="titulo">Exemplo de Código</h1>
            <p><span class="codigo">valor.equalsIgnoreCase("v")</span>Verifica se a String é igual ao valor passado ignorando maiúsculo e minúsculo.</p>
            
        </section>
        <!-- Data e Hora -->
         <section>
            <h1 class="titulo">Data e Hora com Java</h1>
            <h2>Utilizado API java.time</h2>
            <h3>Classes mais utilizadas:</h3>
            <ul class="ul">
                <li><strong>LocalDate</strong> para trabalhar com data</li>
                <li><strong>LocalTime</strong> para trabalhar somente com hora</li>
                <li><strong>LocalDateTime</strong> para trabalhar com data e hora completas</li>
            </ul>
            <h3>Métodos mais utilizados:</h3>
            <ul class="ul">
                <li><strong>of()</strong>, que recebe o ano, mês e dia, ou, no caso de hora, a hora e o minuto</li>
                <li><strong>parse()</strong>, que recebe uma string no formato ISO e a converte</li>
                <li><strong>now()</strong>, que retorna o momento exato atual, seja a data, o horário ou ambos</li>
            </ul>
            <h2>Exemplos</h2>
            <p class="codigo">import java.time.LocalDate;</p>
            <p>Para que ela receba a data de hoje, utilizaremos <strong>LocalDate.now()</strong>, que retorna a data atual. Isso também se aplica a <strong>LocalTime e LocalDateTime</strong>.</p>
            <p class="codigo">LocalDate dataCompra = LocalDate.now();</p>
            <p>Determinar o ano, mês e dia usando <strong>LocalDate.of()</strong>.</p>
            <p class="codigo">LocalDate dataPrimeiraParcela = LocalDate.of(2025, 5, 15);</p>
            <p>Se quisermos que a variável dataSegundaParcela receba uma data 30 dias após a primeira parcela, utilizaremos <strong>plusDays(30)</strong>.</p>
            <p class="codigo">LocalDate dataSegundaParcela = dataPrimeiraParcela.plusDays(30);</p>
            <p>Usamos o plusDays(), mas existem outros métodos disponíveis para todos. Por exemplo:</p>
            <ul class="ul">
                <li>plusWeeks(), plusMonths() e plusYears(), que servem para adicionar</li>
                <li>minusDays(), minusWeeks(), minusMonths() e minusYears(), que servem para subtrair</li>
            </ul>
            <h2>Verificando datas</h2>
            <p>Além de adicionar e subtrair datas, podemos fazer verificações, como se uma data é antes ou depois de outra com os seguintes métodos:</p>
            <ul class="ul">
                <li>isBefore();</li>
                <li>isAfter();</li>
                <li>isEqual().</li>
            </ul>
            <p>Por exemplo, podemos verificar se a data da primeira parcela é igual à data atual usando isEqual(LocalDate.now()), que retorna um valor booliano. Acima dos prints, criaremos o seguinte bloco para verificar se a data atual é o dia do vencimento:</p>
            <pre>
                if (dataPrimeiraParcela.isEqual(LocalDate.now())) {
                    System.out.println("Hoje é o dia do vencimento");
                } else {
                    System.out.println("Ainda não está no dia do vencimento");
                }
            </pre>
            <h2>Formatando datas</h2>
            <p>O <strong>LocalDate</strong> segue o padrão ISO 8601, que exibe datas no <strong>formato ano-mês-dia</strong>. No entanto, podemos querer mostrar em um padrão diferente.</p>
            <p>Podemos formatar a data usando <strong>DateTimeFormatter</strong> para criar o formato no padrão brasileiro. Por exemplo, abaixo dos prints, podemos criar um <strong>DateTimeFormatter</strong> chamado formato, usando <strong>DateTimeFormatter.ofPattern("dd/MM/yyyy")</strong>, onde dd/MM/yyyy define o padrão dia/mês/ano.</p>
            <p>Utilizamos <strong>MM</strong> maiúsculo para definir meses, pois <strong>mm</strong> minúsculo define os minutos.</p>
            <p class="codigo">DateTimeFormatter formato = DateTimeFormatter.ofPattern("dd/MM/yyyy");</p>
            <p class="codigo">System.out.println("Data compra formatada: " + dataCompra.format(formato));</p>
            <h2>Trabalhando com fusos horários</h2>
            <p>Além de podermos formatar as datas no padrão desejado, escolhendo se queremos apenas o mês e o ano, se queremos o ano com quatro dígitos ou com dois, e definir exatamente o padrão através do <strong>DateTimeFormatter.ofPattern()</strong>, também podemos trabalhar por meio da orientação a fusos horários.</p>
            <p>Vamos supor que queiramos trabalhar com uma data baseada em um fuso horário e que possamos verificar qual seria essa data em outro fuso horário. Para fazer isso, vamos criar uma data de conclusão da compra para armazenar o momento exato da conclusão da compra.</p>
            <p>Queremos observar esse horário de conclusão tanto no Brasil quanto no padrão dos Estados Unidos. Para isso, utilizaremos a classe <strong>ZonedDateTime</strong>, que é um <strong>DateTime</strong> baseado no fuso horário.</p>
            <p>Vamos criar uma variável dataConclusaoCompra e definir como <strong>ZonedDateTime.now()</strong>, que representa o momento atual.</p>
            <p class="codigo">ZonedDateTime dataConclusaoCompra = ZonedDateTime.now();</p>
            <p class="codigo">ZonedDateTime dataCompraNy = dataConclusaoCompra.<span class="pre1">withZoneSameInstant</span>(<span class="preAmarelo">ZoneId.of</span>(America/New_York));</p>
            <h2>Calculando a diferença entre datas e horas</h2>
            <p>Agora, faremos um exercício sobre o cálculo de diferença entre datas e horas, utilizando <strong>Duration</strong> e <strong>Period</strong>.</p>
            <p>O <strong>Duration</strong> é geralmente usado para horas. Vamos fazer um teste para ver nosso horário de trabalho (quanto tempo de expediente estamos trabalhando).</p>
            <pre>
                LocalTime inicio = LocalTime.of(9, 0);
                LocalTime fim = LocalTime.of(17, 30);
                Duration duracao = Duration.between(inicio, fim);
                System.out.println("Duração do expediente: " + duracao.toHours() + 
                   " horas e " + duracao.toMinutesPart() + " minutos.");
            </pre>
            <p>Agora para calcular dias:</p>
            <pre>
                LocalDate dataPagamento = LocalDate.parse("2025-10-30");
                LocalDate dataPag2 = dataCompra.plusDays(45);
                
                long totalDias = ChronoUnit.DAYS.between(dataCompra, dataPag2);

                System.out.println("Data da compra: " + dataCompra + "\nData Pagamento: " + dataPag2 + "\nDiferença em dias: " + totalDias);
            </pre>
         </section>
    </main>
    
</body>
</html>