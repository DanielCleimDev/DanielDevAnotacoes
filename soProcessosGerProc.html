<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="css/so.css">
  <title>Processos e Gerencia de Processador</title>
</head>
<body>
  <main>
    <section>
      <h1>Processos e Gerencia de Processador</h1>
      <section>
        <ul>
          <li>
            <h2>Instalando o compilador de Linguagem C no Ubuntu</h2>
            <p class="codigo">sudo apt-get update</p>
            <p class="codigo">sudo apt-get install gcc</p>
          </li>
          <li>
            <h2>Compilando</h2>
            <p>Para compilar um programa chamado prog.c basta entrar no shell, no diretório onde se encontra o programa, e executar o comando:</p>
            <p class="codigo">gcc prog.c</p>
            <p>Será criado um arquivo executável de nome <strong>a.out</strong>.</p>
          </li>
          <li>
            <h2>Compilando especificando a saída</h2>
            <p>Para compilar um programa e escolher o nome do arquivo executável que será gerado, utilize o parâmetro <strong>-o</strong>. Por exemplo, para compilar o programa <strong>prog.c</strong> e gerar como saída um arquivo executável <strong>prog</strong>, utilize o comando:</p>
            <p class="codigo">gcc prog.c -o prog</p>
          </li>
          <li>
            <h2>Executando o programa</h2>
            <p>Para executar o programa <strong>prog</strong> que acabou de ser compilado, execute o comando:</p>
            <p class="codigo">./prog</p>
          </li>
        </ul>
      </section>
      <section>
        <h2>Modelo de processo</h2>
        <h2>Sistema multiprogramável</h2>
        <p>A unidade central de processamento (UCP) alterna entre processos, dedicando um pouco de seu tempo a cada um, dando a ilusão de paralelismo. Este esquema costuma ser chamado de pseudoparalelismo.</p>
        <p>Um processo é um programa em execução, incluindo os valores atuais dos registradores e variáveis, assim como seu espaço de endereçamento. Um programa por si só não é um processo, mas uma entidade passiva. Um processo é uma entidade ativa, com um contador de instruções e um conjunto de registradores a ele associado.</p>
        <section>
          <h3>Espaço de endereçamento</h3>
          <p>Conjunto de endereços de memória que um processo pode acessar.</p>
        </section>
        <section>
          <h3>Contador de instruções</h3>
          <p>Registrador de uma unidade central de processamento que indica qual é a posição atual na sequência de execução de um processo. Dependendo dos detalhes da arquitetura, ele armazena o endereço da instrução que está sendo executada ou o endereço da próxima instrução.</p>
        </section>
        <h3>Daemons</h3>
        <p>São processos que ficam em segundo plano.</p>
        <p>Em todos esses casos, um novo processo é criado por outro já existente, executando uma chamada de sistema de criação de processo. O que esse processo faz é executar uma chamada de sistema para criar o processo.</p>
        <p>No Linux, um processo especial chamado <strong>systemd</strong> (ou <strong>init</strong>, dependendo da versão) está presente na imagem de inicialização do sistema. É o primeiro processo a ser executado e é responsável por iniciar a execução dos demais processos do sistema operacional. Cada um desses processos pode iniciar mais processos. Desse modo, todos os processos no Linux pertencem a uma única árvore, com o systemd (ou init) em sua raiz.</p>
        <section>
          <h2>Estados de um processo</h2>
          <p>Um processo pode ter vários estados, geralmente são eles: <strong>Novo, Pronto, Bloqueado, Terminado.</strong></p>
        </section>
        <h2>Bloco de Controle de Processo</h2>
        <p>Para implementar o modelo de processos, o Linux mantém uma tabela de processos, com uma entrada por processo. Esta entrada é chamada de Bloco de Controle de Processo - <strong> BCP (Process Control Block - PCB)</strong> e contém todas as informações do processo. Algumas entradas do BCP são:</p>
        <h2>Escalonador</h2>
        <p>O nível mais baixo do sistema operacional é o escalonador (também conhecido como agendador). Ele cuida do gerenciamento de interrupções e dos detalhes de como iniciar e parar processos. Também costuma ser muito pequeno.</p>
        <p>Um processo passa pelas várias filas de seleção durante sua execução. Cabe ao escalonador selecionar processos destas filas e decidir qual será o próximo a ser executado.</p>
        <section>
          <h2>Mudança de contexto</h2>
          <p>Para transferir o controle da UCP de um processo a outro, é necessário guardar o estado do processo em execução e carregar o estado do processo a entrar em execução. Esta tarefa é conhecida como mudança de contexto (ou troca de contexto).</p>
          <h2>O contexto de um processo pode ser dividido em três elementos básicos:</h2>
          <ul>
            <li>
              <h3>Contexto de hardware</h3>
              <p>O contexto de hardware constitui-se basicamente do conteúdo dos registradores. No momento em que o processo perde a UCP, o sistema salva suas informações. Ele é fundamental para a implementação dos sistemas multiprogramáveis.</p>
            </li>
            <li>
              <h3>Contexto de software</h3>
              <p>O contexto de software especifica características do processo que influenciarão na execução de um programa. Ele define basicamente três grupos de informações sobre um processo: identificação, quotas e privilégios. A identificação define o processo para o sistema de forma única, através de seu PID, UID e GID. Quotas são os limites de cada recurso que o sistema operacional pode alocar, como número de arquivos abertos, quantidade de memória, quantidade de subprocessos que podem ser criados etc. Privilégio é o que o processo pode ou não fazer em relação ao sistema e outros processos.</p>
            </li>
            <li>
              <h3>Espaço de endereçamento</h3>
              <p>O espaço de endereçamento é a área de memória do processo em que o programa será executado e a área de memória onde os dados do processo serão armazenados. Cada processo possui seu próprio espaço de endereçamento, que deve ser protegido dos demais.</p>
            </li>
          </ul>
        </section>
        <h2>Algumas chamadas de sistema do Linux para o gerenciamento de processos são:</h2>
        <section class="tabela-grid">
          <p class="tabela-titulo">Chamada de sistema</p>
          <p class="tabela-titulo">Descrição</p>
          
          <p>fork()</p>
          <p>A chamada de sistema fork() cria um subprocesso que é cópia exata do processo pai, mas que compartilha com ele apenas os arquivos abertos. Portanto, não há compartilhamento do espaço de endereçamento com o processo pai. Para executar o código de outro programa, é necessário utilizar a chamada de sistema execve() após a chamada de sistema fork(). Retorna o PID do processo filho e, para o processo filho, retorna o valor 0. </p>
          
          <p>waitpid()</p>
          <p>Espera até que o processo filho passado como parâmetro termine sua execução.</p>
          
          <p>execve()</p>
          <p>Substitui a imagem de execução de um processo, fazendo com que, no lugar do processo corrente, seja executado o código do programa passado como parâmetro.</p>
          
          <p>exit()</p>
          <p>Termina a execução do processo e retorna como status o valor passado como parâmetro.</p>
        </section>
        <section>
          <h1>Subprocesso</h1>
          <p>Quando um processo (processo pai) cria um outro processo, ele é conhecido como subprocesso ou processo filho. O subprocesso, por sua vez, pode criar outros subprocessos.</p>
          <p>A utilização de subprocessos permite dividir uma aplicação em partes que podem trabalhar de forma concorrente.</p>
          <section>
            <h2>Exemplo</h2>
            <p>Um servidor web que aceite requisições de clientes da internet e coloque as requisições em uma fila. Uma forma simples de implementar este servidor seria criar um processo que pegue a primeira requisição da fila, processe a requisição e devolva o resultado do processamento ao cliente que a solicitou. Após isso, ele pegaria a próxima requisição e faria o mesmo trabalho.</p>
          </section>
          <p>O problema com essa solução é que ela não aproveita a capacidade de multiprocessamento dos sistemas atuais. Como existe apenas um processo em execução, somente um dos processadores do sistema é utilizado para atendimento das requisições. Além disso, se houver várias requisições complexas e demoradas e uma requisição simples, como uma pequena página HTML, entrar no final da fila, esta requisição mais simples, que poderia ser respondida rapidamente, será atendida somente depois que todas as demais forem processadas.</p>
          <p>A utilização de subprocessos resolve bem estes problemas. Se o servidor, no lugar de responder sequencialmente a cada requisição, criar um subprocesso para cada uma delas, tirará proveito da capacidade de multiprocessamento do sistema. Como cada requisição será tratada por um processo diferente, as requisições serão espalhadas pelos processadores do sistema, aproveitando sua capacidade de multiprocessamento. Além disso, como as requisições serão tratadas por diferentes processos, elas serão executadas concorrentemente.</p>
        </section>
        <section>
          <h2>Threads</h2>
          <p>Na tentativa de diminuir o tempo gasto na criação/eliminação de processos, bem como economizar recursos do sistema, foi introduzido o conceito de thread. Em um ambiente com múltiplos threads, não é necessário haver vários processos para implementar aplicações concorrentes.</p>
          <p>Threads compartilham o processador da mesma maneira que um processo. Cada thread possui seu próprio conjunto de registradores (contexto de hardware), porém compartilha o mesmo espaço de endereçamento com os demais threads do processo. No momento em que um thread perde a utilização do processador, o sistema salva suas informações. Threads passam pelos mesmos estados que um processo.</p>
          <p>A grande diferença entre subprocessos e threads é em relação ao espaço de endereçamento.</p>
          <section>
            <p><strong>Subprocessos</strong> possuem, cada um, espaços independentes e protegidos.</p>
            <p><strong>Threads</strong>, por outro lado, compartilham o mesmo espaço de endereçamento do processo, sem nenhuma proteção, permitindo que um thread possa alterar dados de outro thread. São desenvolvidos para trabalharem de forma cooperativa, voltados para desempenhar uma tarefa em conjunto, e são conhecidos como <strong> processos leves</strong>.</p>
            <section>
              <p>Threads são muito úteis em sistemas com múltiplas UCP, nos quais o paralelismo real é possível. Elas permitem que ocorram múltiplas execuções no mesmo ambiente, fazendo com que várias partes de um mesmo processo estejam em execução concorrente em diferentes processadores.</p>
            </section>
            <p>Além de compartilhar o espaço de endereçamento, os threads podem compartilhar o mesmo conjunto de arquivos abertos, processos filhos, alarmes e sinais.</p>
            <p>É importante perceber que cada thread tem a sua própria pilha, que contém uma estrutura para cada rotina chamada, mas ainda não retornada. Essa estrutura contém as variáveis locais da rotina e o endereço de retorno para serem usados quando a chamada de rotina for encerrada.</p>
            <p>No Linux, os threads são criados com a chamada de sistema <strong>clone()</strong>. Sua sintaxe é:</p>
            <p class="codigo">int clone(int (*fn)(void *), void *stack, int flags, void *arg)</p>
          </section>
        </section>
        <section>
          <h2>Tipos de processos</h2>
          <p>Existem basicamente dois tipos de processos relacionados ao tipo de processamento que executam</p>
          <h3>CPU-bound</h3>
          <p>Os processos do tipo CPU-bound passam a maior parte do tempo no estado executando, realizando poucas operações de E/S. Costumam ser encontrados em aplicações científicas.</p>
          <h3>I/O-bound</h3>
          <p>Os processos do tipo I/O-bound passam a maior parte do tempo no estado bloqueado, por realizar elevado número de operações de E/S. Costumam ser encontrados em aplicações comerciais. Processos interativos também são exemplos deste tipo de processo.</p>
        </section>
        <section>
          <h2>Processos e threads no Linux</h2>
          <p>O Linux pode duplicar um processo por meio da chamada de sistema <strong>fork()</strong>, mas também pode criar threads pela chamada de sistema <strong>clone()</strong>. No entanto, ele não faz distinção entre processos e threads. Toda entidade em execução, processo ou thread, será considerada como uma <strong>tarefa (task)</strong>. Um processo com um único thread será considerado como uma tarefa, e um processo com n threads terá n estruturas de tarefas.</p>
          <section>
            <p>As chamas de sistema fork() e clone() são bastante semelhantes. De fato, se clone() for invocada sem nenhum flag passado como parâmetro, seu comportamento será idêntico ao fork().</p>
          </section>
          <h3>Cópia do segmento compartilhado - copy on write</h3>
          <p>Se os processos se limitarem à operação de consulta nos segmentos, não haverá problema, mas, se algum dos processos tentar escrever em um dos segmentos, neste momento, haverá a cópia do segmento compartilhado (mecanismo conhecido como cópia na escrita – copy on write). Além de aumentar o desempenho do sistema, esse mecanismo ajuda a diminuir o consumo de memória física.</p>
        </section>
      </section>
      <section>
        <h1>PROCESSOS DE APLICAÇÕES CONCORRENTES</h1>
        <p>Os mecanismos que garantem a comunicação entre processos concorrentes e o acesso a recursos compartilhados são chamados <strong>mecanismos de sincronização</strong>. Os mesmos mecanismos se aplicam a threads.</p>
        <h3>Condição de corrida</h3>
        <p>Ocorre quando dois ou mais processos estão acessando dados compartilhados e o resultado do processamento depende de quem executa e quando é executado.</p>
        <h2>Região Crítica</h2>
        <h3>Exclusão mútua</h3>
        <p>Quando um processo estiver acessando o recurso compartilhado, os demais deverão esperar.</p>
        <h3>Seção crítica ou região crítica (RC)</h3>
        <p>É quando parte do programa acessa memória compartilhada. Quando um processo é executado dentro de sua região crítica, nenhum outro processo pode entrar lá.</p>
        <p>Não é suficiente evitar que o processo seja interrompido dentro da região crítica. São quatro as condições para uma boa solução:</p>
        <ul>
          <li>Não pode haver mais de um processo simultaneamente dentro de suas regiões críticas.</li>
          <li>Nenhuma suposição pode ser feita sobre a velocidade ou o número de UCP.</li>
          <li>Nenhum processo que execute fora de sua região crítica pode bloquear outro processo.</li>
          <li>Nenhum processo deve ter de esperar eternamente para entrar em sua região crítica (starvation).</li>
        </ul>
        <p>Para garantir a implementação da exclusão mútua, os processos envolvidos devem fazer acesso aos recursos compartilhados de forma sincronizada.</p>
        <section>
          <h2>Semáfotos</h2>
          <ul>
            <li>
              <h3>down</h3>
              <p>A operação down decrementa o valor do semáforo se ele for maior que 0, senão o processo é bloqueado.</p>
            </li>
            <li>
              <h3>up</h3>
              <p>A operação up incrementa o valor do semáforo caso não haja processos que tenham sido bloqueados pela operação down, senão um processo é desbloqueado.</p>
            </li>
          </ul>
          <p>No caso da exclusão mútua, as instruções down e up funcionam como protocolos para que um processo possa entrar e sair de sua região crítica. O semáforo fica associado a um recurso compartilhado, indicando quando o recurso está sendo acessado por um dos processos concorrentes. Se seu valor for maior que 0, nenhum processo está utilizando o recurso. Caso contrário, o processo fica impedido de acessar o recurso.</p>
          <p><strong>As operações up e down são realizadas pelo sistema operacional, que deve garantir que elas sejam executadas atomicamente.</strong></p>
        </section>
        <section>
          <h2>Monitores</h2>
          <p>Um monitor é uma coleção de variáveis, procedimentos e estruturas de dados que são agrupados em um pacote. Em determinado instante, somente um processo pode estar ativo em um monitor. Toda vez que algum processo chama um procedimento do monitor, ele verifica se já existe outro processo executando qualquer procedimento do monitor. Caso exista, o processo ficará aguardando a sua vez, até que tenha permissão para executar.</p>
        </section>
        <section>
          <h2>SINCRONIZAÇÃO NO LINUX</h2>
          <p>O Linux oferece suporte à utilização de semáforos para sincronização de tarefas por meio da chamada de sistema <strong>sem_wait()</strong>, que realiza a operação <strong>up()</strong>, e da chamada de sistema <strong>sem_post()</strong>, que realiza a operação <strong>down()</strong>. Porém, em algumas situações, a tarefa pode querer apenas verificar se é possível prosseguir, mas não é interessante bloquear, caso não possa prosseguir. Para esses casos, pode ser utilizada a chamada de sistema <strong>sem_trywait()</strong>, que tem funcionamento parecido com a sem_wait(), exceto pelo fato de que, se o decremento não puder ser executado imediatamente, a chamada de sistema retorna um erro sem bloqueio.</p>
          <p>A <strong>troca de mensagens</strong> pode ser implementada pelo mecanismo de pipe. O <strong>pipe</strong> ( | ) é um mecanismo especial de redirecionamento utilizado para conectar a saída padrão de um processo à entrada padrão de outro processo. Por exemplo, os comandos a seguir juntam todos os arquivos com extensão “.txt”, ordenando suas linhas e retirando as duplicadas.</p>
          <p class="codigo">cat *.txt | sort | uniq</p>
          <p>Entenda o significado de cada um deles:</p>
          <ul>
            <li><p>O comando “cat *.txt” joga na saída padrão (tela) o conteúdo de todos os arquivos presentes no diretório e que possuem extensão “.txt”.</p></li>
            <li><p>O comando “sort” recebe linhas por sua entrada padrão (inicialmente, o teclado), ordena as linhas e envia as linhas devidamente ordenadas para a saída padrão.</p></li>
            <li><p>O comando “uniq” recebe linhas por sua entrada padrão e elimina as linhas duplicadas, enviando para a saída padrão somente as linhas que não estão em duplicidade.</p></li>
          </ul>
          <p>Quando é utilizada a barra vertical ( | ) entre os comandos, é introduzido um pipe entre as tarefas, ou seja, as tarefas são colocadas em execução concorrente, e a saída padrão da tarefa à esquerda do pipe é conectada à entrada padrão da tarefa à direita do pipe. Assim, no exemplo, a saída do comando “cat *.txt” é enviada para a entrada do comando “sort”, que faz a ordenação, e sua saída é enviada à entrada do comando “uniq”, que elimina as linhas repetidas e, finalmente, joga o resultado de seu processamento para a saída padrão (o monitor, por padrão).</p>
          <p>Outra forma de comunicação entre processos no Linux ocorre por meio de envio de sinais, que são enviados na ocorrência de eventos, como a chegada de uma informação pela rede, o fim de um temporizador, o término da execução de um processo filho etc. São eventos que chegam ao processo e precisam ser tratados de alguma forma. Para isso, é necessário definir uma rotina para o tratamento do evento.</p>
          <section>
            <p>São exemplos de sinais do Linux:</p>
            <div class="tabela-grid_cl_3">
              <p class="tabela-titulo">Sinal</p>
              <p class="tabela-titulo">Ação padrão</p>
              <p class="tabela-titulo">Comentário</p>

              <p>SIGHUP</p>
              <p>Terminar</p>
              <p>Gerado pelo fim do terminal controlador.</p>

              <p>SIGTERM</p>
              <p>Terminar</p>
              <p>Informa que deve parar a execução.</p>

              <p>SIGINT</p>
              <p>Terminar</p>
              <p>Recebeu uma interrupção + pelo terminal controlador.</p>

              <p>SIGKILL</p>
              <p>Terminal</p>
              <p>	Força a finalização do processo.</p>

              <p>SIGTSTP</p>
              <p>Suspender</p>
              <p>Processo deve ser suspenso (+).</p>

              <p>SIGSTOP</p>
              <p>Suspender</p>
              <p>Processo deve ser suspenso. Semelhante ao SIGTSTP, mas não pode ser sobrescrito.</p>

              <p>SIGCONT</p>
              <p> </p>
              <p>Retornar à execução se estiver suspenso.</p>

              <p>SIGCHLD</p>
              <p>Ignorar</p>
              <p>Informa ao processo pai que um processo filho terminou ou foi suspenso.</p>

              <p>SIGALRM</p>
              <p>Terminar</p>
              <p>Fim de temporizador.</p>

              <p>SIGURG</p>
              <p>Ignorar</p>
              <p>Condição urgente no socket. Normalmente, aviso de chegada de pacote de rede.</p>

              <p>SIGUSR1</p>
              <p>Terminar</p>
              <p>Sinal definido pelo usuário.</p>

              <p>SIGUSR2</p>
              <p>Terminar</p>
              <p>Sinal definido pelo usuário.</p>
            </div>
          </section>
          <section>
            <p>As principais chamadas de sistema relativas ao tratamento de sinais são:</p>
            <div class="tabela-grid">
              <p class="tabela-titulo">Chamada de sistema</p>
              <p class="tabela-titulo">Descrição</p>

              <p>signal()</p>
              <p>Instala rotina para tratamento do sinal.</p>

              <p>sigaction()</p>
              <p>Define a ação a ser tomada nos sinais.</p>

              <p>sigreturn()</p>
              <p>Retorna de um sinal.</p>

              <p>sigpending()</p>
              <p>	Obtém o conjunto de sinais bloqueados.</p>

              <p>kill ()</p>
              <p>Envia um sinal para um processo.</p>

              <p>alarm()</p>
              <p>	Ajusta o alarme do relógio para envio de um sinal.</p>

              <p>pause()</p>
              <p>Suspende o chamador até o próximo sinal.</p>
            </div>
          </section>
        </section>
      </section>
    </section>
  </main>
  <!--
    Tema 3 - Processos e Gerencia de Processador
    ESCALONAMENTO
  -->
</body>
</html>