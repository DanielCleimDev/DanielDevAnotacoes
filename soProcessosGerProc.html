<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="css/so.css">
  <title>Processos e Gerencia de Processador</title>
</head>
<body>
  <main>
    <section>
      <h1>Processos e Gerencia de Processador</h1>
      <section>
        <ul>
          <li>
            <h2>Instalando o compilador de Linguagem C no Ubuntu</h2>
            <p class="codigo">sudo apt-get update</p>
            <p class="codigo">sudo apt-get install gcc</p>
          </li>
          <li>
            <h2>Compilando</h2>
            <p>Para compilar um programa chamado prog.c basta entrar no shell, no diretório onde se encontra o programa, e executar o comando:</p>
            <p class="codigo">gcc prog.c</p>
            <p>Será criado um arquivo executável de nome <strong>a.out</strong>.</p>
          </li>
          <li>
            <h2>Compilando especificando a saída</h2>
            <p>Para compilar um programa e escolher o nome do arquivo executável que será gerado, utilize o parâmetro <strong>-o</strong>. Por exemplo, para compilar o programa <strong>prog.c</strong> e gerar como saída um arquivo executável <strong>prog</strong>, utilize o comando:</p>
            <p class="codigo">gcc prog.c -o prog</p>
          </li>
          <li>
            <h2>Executando o programa</h2>
            <p>Para executar o programa <strong>prog</strong> que acabou de ser compilado, execute o comando:</p>
            <p class="codigo">./prog</p>
          </li>
        </ul>
      </section>
      <section>
        <h2>Modelo de processo</h2>
        <h2>Sistema multiprogramável</h2>
        <p>A unidade central de processamento (UCP) alterna entre processos, dedicando um pouco de seu tempo a cada um, dando a ilusão de paralelismo. Este esquema costuma ser chamado de pseudoparalelismo.</p>
        <p>Um processo é um programa em execução, incluindo os valores atuais dos registradores e variáveis, assim como seu espaço de endereçamento. Um programa por si só não é um processo, mas uma entidade passiva. Um processo é uma entidade ativa, com um contador de instruções e um conjunto de registradores a ele associado.</p>
        <section>
          <h3>Espaço de endereçamento</h3>
          <p>Conjunto de endereços de memória que um processo pode acessar.</p>
        </section>
        <section>
          <h3>Contador de instruções</h3>
          <p>Registrador de uma unidade central de processamento que indica qual é a posição atual na sequência de execução de um processo. Dependendo dos detalhes da arquitetura, ele armazena o endereço da instrução que está sendo executada ou o endereço da próxima instrução.</p>
        </section>
        <h3>Daemons</h3>
        <p>São processos que ficam em segundo plano.</p>
        <p>Em todos esses casos, um novo processo é criado por outro já existente, executando uma chamada de sistema de criação de processo. O que esse processo faz é executar uma chamada de sistema para criar o processo.</p>
        <p>No Linux, um processo especial chamado <strong>systemd</strong> (ou <strong>init</strong>, dependendo da versão) está presente na imagem de inicialização do sistema. É o primeiro processo a ser executado e é responsável por iniciar a execução dos demais processos do sistema operacional. Cada um desses processos pode iniciar mais processos. Desse modo, todos os processos no Linux pertencem a uma única árvore, com o systemd (ou init) em sua raiz.</p>
        <section>
          <h2>Estados de um processo</h2>
          <p>Um processo pode ter vários estados, geralmente são eles: <strong>Novo, Pronto, Bloqueado, Terminado.</strong></p>
        </section>
        <h2>Bloco de Controle de Processo</h2>
        <p>Para implementar o modelo de processos, o Linux mantém uma tabela de processos, com uma entrada por processo. Esta entrada é chamada de Bloco de Controle de Processo - <strong> BCP (Process Control Block - PCB)</strong> e contém todas as informações do processo. Algumas entradas do BCP são:</p>
        <h2>Escalonador</h2>
        <p>O nível mais baixo do sistema operacional é o escalonador (também conhecido como agendador). Ele cuida do gerenciamento de interrupções e dos detalhes de como iniciar e parar processos. Também costuma ser muito pequeno.</p>
        <p>Um processo passa pelas várias filas de seleção durante sua execução. Cabe ao escalonador selecionar processos destas filas e decidir qual será o próximo a ser executado.</p>
        <section>
          <h2>Mudança de contexto</h2>
          <p>Para transferir o controle da UCP de um processo a outro, é necessário guardar o estado do processo em execução e carregar o estado do processo a entrar em execução. Esta tarefa é conhecida como mudança de contexto (ou troca de contexto).</p>
          <h2>O contexto de um processo pode ser dividido em três elementos básicos:</h2>
          <ul>
            <li>
              <h3>Contexto de hardware</h3>
              <p>O contexto de hardware constitui-se basicamente do conteúdo dos registradores. No momento em que o processo perde a UCP, o sistema salva suas informações. Ele é fundamental para a implementação dos sistemas multiprogramáveis.</p>
            </li>
            <li>
              <h3>Contexto de software</h3>
              <p>O contexto de software especifica características do processo que influenciarão na execução de um programa. Ele define basicamente três grupos de informações sobre um processo: identificação, quotas e privilégios. A identificação define o processo para o sistema de forma única, através de seu PID, UID e GID. Quotas são os limites de cada recurso que o sistema operacional pode alocar, como número de arquivos abertos, quantidade de memória, quantidade de subprocessos que podem ser criados etc. Privilégio é o que o processo pode ou não fazer em relação ao sistema e outros processos.</p>
            </li>
            <li>
              <h3>Espaço de endereçamento</h3>
              <p>O espaço de endereçamento é a área de memória do processo em que o programa será executado e a área de memória onde os dados do processo serão armazenados. Cada processo possui seu próprio espaço de endereçamento, que deve ser protegido dos demais.</p>
            </li>
          </ul>
        </section>
        <h2>Algumas chamadas de sistema do Linux para o gerenciamento de processos são:</h2>
        <section class="tabela-grid">
          <p class="tabela-titulo">Chamada de sistema</p>
          <p class="tabela-titulo">Descrição</p>
          
          <p>fork()</p>
          <p>A chamada de sistema fork() cria um subprocesso que é cópia exata do processo pai, mas que compartilha com ele apenas os arquivos abertos. Portanto, não há compartilhamento do espaço de endereçamento com o processo pai. Para executar o código de outro programa, é necessário utilizar a chamada de sistema execve() após a chamada de sistema fork(). Retorna o PID do processo filho e, para o processo filho, retorna o valor 0. </p>
          
          <p>waitpid()</p>
          <p>Espera até que o processo filho passado como parâmetro termine sua execução.</p>
          
          <p>execve()</p>
          <p>Substitui a imagem de execução de um processo, fazendo com que, no lugar do processo corrente, seja executado o código do programa passado como parâmetro.</p>
          
          <p>exit()</p>
          <p>Termina a execução do processo e retorna como status o valor passado como parâmetro.</p>
        </section>
        <section>
          <h1>Subprocesso</h1>
          <p>Quando um processo (processo pai) cria um outro processo, ele é conhecido como subprocesso ou processo filho. O subprocesso, por sua vez, pode criar outros subprocessos.</p>
          <p>A utilização de subprocessos permite dividir uma aplicação em partes que podem trabalhar de forma concorrente.</p>
          <section>
            <h2>Exemplo</h2>
            <p>Um servidor web que aceite requisições de clientes da internet e coloque as requisições em uma fila. Uma forma simples de implementar este servidor seria criar um processo que pegue a primeira requisição da fila, processe a requisição e devolva o resultado do processamento ao cliente que a solicitou. Após isso, ele pegaria a próxima requisição e faria o mesmo trabalho.</p>
          </section>
          <p>O problema com essa solução é que ela não aproveita a capacidade de multiprocessamento dos sistemas atuais. Como existe apenas um processo em execução, somente um dos processadores do sistema é utilizado para atendimento das requisições. Além disso, se houver várias requisições complexas e demoradas e uma requisição simples, como uma pequena página HTML, entrar no final da fila, esta requisição mais simples, que poderia ser respondida rapidamente, será atendida somente depois que todas as demais forem processadas.</p>
          <p>A utilização de subprocessos resolve bem estes problemas. Se o servidor, no lugar de responder sequencialmente a cada requisição, criar um subprocesso para cada uma delas, tirará proveito da capacidade de multiprocessamento do sistema. Como cada requisição será tratada por um processo diferente, as requisições serão espalhadas pelos processadores do sistema, aproveitando sua capacidade de multiprocessamento. Além disso, como as requisições serão tratadas por diferentes processos, elas serão executadas concorrentemente.</p>
        </section>
        <section>
          <h2>Threads</h2>
          <p>Na tentativa de diminuir o tempo gasto na criação/eliminação de processos, bem como economizar recursos do sistema, foi introduzido o conceito de thread. Em um ambiente com múltiplos threads, não é necessário haver vários processos para implementar aplicações concorrentes.</p>
          <p>Threads compartilham o processador da mesma maneira que um processo. Cada thread possui seu próprio conjunto de registradores (contexto de hardware), porém compartilha o mesmo espaço de endereçamento com os demais threads do processo. No momento em que um thread perde a utilização do processador, o sistema salva suas informações. Threads passam pelos mesmos estados que um processo.</p>
          <p>A grande diferença entre subprocessos e threads é em relação ao espaço de endereçamento.</p>
          <section>
            <p><strong>Subprocessos</strong> possuem, cada um, espaços independentes e protegidos.</p>
            <p><strong>Threads</strong>, por outro lado, compartilham o mesmo espaço de endereçamento do processo, sem nenhuma proteção, permitindo que um thread possa alterar dados de outro thread. São desenvolvidos para trabalharem de forma cooperativa, voltados para desempenhar uma tarefa em conjunto, e são conhecidos como <strong> processos leves</strong>.</p>
            <section>
              <p>Threads são muito úteis em sistemas com múltiplas UCP, nos quais o paralelismo real é possível. Elas permitem que ocorram múltiplas execuções no mesmo ambiente, fazendo com que várias partes de um mesmo processo estejam em execução concorrente em diferentes processadores.</p>
            </section>
            <p>Além de compartilhar o espaço de endereçamento, os threads podem compartilhar o mesmo conjunto de arquivos abertos, processos filhos, alarmes e sinais.</p>
            <p>É importante perceber que cada thread tem a sua própria pilha, que contém uma estrutura para cada rotina chamada, mas ainda não retornada. Essa estrutura contém as variáveis locais da rotina e o endereço de retorno para serem usados quando a chamada de rotina for encerrada.</p>
            <p>No Linux, os threads são criados com a chamada de sistema <strong>clone()</strong>. Sua sintaxe é:</p>
            <p class="codigo">int clone(int (*fn)(void *), void *stack, int flags, void *arg)</p>
          </section>
        </section>
        <section>
          <h2>Tipos de processos</h2>
          <p>Existem basicamente dois tipos de processos relacionados ao tipo de processamento que executam</p>
          <h3>CPU-bound</h3>
          <p>Os processos do tipo CPU-bound passam a maior parte do tempo no estado executando, realizando poucas operações de E/S. Costumam ser encontrados em aplicações científicas.</p>
          <h3>I/O-bound</h3>
          <p>Os processos do tipo I/O-bound passam a maior parte do tempo no estado bloqueado, por realizar elevado número de operações de E/S. Costumam ser encontrados em aplicações comerciais. Processos interativos também são exemplos deste tipo de processo.</p>
        </section>
        <section>
          <h2>Processos e threads no Linux</h2>
          <p>O Linux pode duplicar um processo por meio da chamada de sistema <strong>fork()</strong>, mas também pode criar threads pela chamada de sistema <strong>clone()</strong>. No entanto, ele não faz distinção entre processos e threads. Toda entidade em execução, processo ou thread, será considerada como uma <strong>tarefa (task)</strong>. Um processo com um único thread será considerado como uma tarefa, e um processo com n threads terá n estruturas de tarefas.</p>
          <section>
            <p>As chamas de sistema fork() e clone() são bastante semelhantes. De fato, se clone() for invocada sem nenhum flag passado como parâmetro, seu comportamento será idêntico ao fork().</p>
          </section>
          <h3>Cópia do segmento compartilhado - copy on write</h3>
          <p>Se os processos se limitarem à operação de consulta nos segmentos, não haverá problema, mas, se algum dos processos tentar escrever em um dos segmentos, neste momento, haverá a cópia do segmento compartilhado (mecanismo conhecido como cópia na escrita – copy on write). Além de aumentar o desempenho do sistema, esse mecanismo ajuda a diminuir o consumo de memória física.</p>
        </section>
      </section>
    </section>
  </main>
  <!--
    Tema 3 - Processos e Gerencia de Processador
    video - processos no linux
  -->
</body>
</html>